<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wazxser.github.io/"/>
  <updated>2019-10-21T05:48:19.205Z</updated>
  <id>https://wazxser.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 7.Reverse Integer</title>
    <link href="https://wazxser.github.io/2019/10/21/Leetcode-7/"/>
    <id>https://wazxser.github.io/2019/10/21/Leetcode-7/</id>
    <published>2019-10-21T03:04:44.000Z</published>
    <updated>2019-10-21T05:48:19.205Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p><p>题意：将整数的数字反转，注意溢出</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        num = str(x)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(num)):</span><br><span class="line">            <span class="keyword">if</span> num[len(num)<span class="number">-1</span>-i].isdigit():</span><br><span class="line">                res = res*<span class="number">10</span> + int(num[len(num)<span class="number">-1</span>-i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="number">0</span> - res</span><br><span class="line">            <span class="keyword">if</span> abs(res) &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>:</span><br><span class="line">                res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int reverse(int x) &#123;</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line">        int num = x;</span><br><span class="line">        long long temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            temp = temp * <span class="number">10</span> + (num % <span class="number">10</span>);</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(temp &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> || temp &lt; -pow(<span class="number">2</span>, <span class="number">31</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res = static_cast&lt;int&gt;(temp);</span><br><span class="line">        //return x &gt; 0 ? res : res * -1;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-integer/&lt;/a
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 22. Generate Parentheses</title>
    <link href="https://wazxser.github.io/2019/10/20/Leetcode-22/"/>
    <id>https://wazxser.github.io/2019/10/20/Leetcode-22/</id>
    <published>2019-10-20T10:21:20.000Z</published>
    <updated>2019-10-20T10:23:30.861Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/</a></p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        dfs(n, n, <span class="string">""</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(int a, int b, string out, vector&lt;string&gt;&amp; res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>)</span><br><span class="line">            res.push_back(out);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span>)</span><br><span class="line">                dfs(a<span class="number">-1</span>, b, out+<span class="string">"("</span>, res);</span><br><span class="line">            <span class="keyword">if</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">                dfs(a, b<span class="number">-1</span>, out+<span class="string">")"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/generate-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/generate-paren
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="DFS" scheme="https://wazxser.github.io/categories/Online-Judge/DFS/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 121. Best Time to Buy and Sell Stock</title>
    <link href="https://wazxser.github.io/2019/10/20/Leetcode-121/"/>
    <id>https://wazxser.github.io/2019/10/20/Leetcode-121/</id>
    <published>2019-10-20T10:03:51.000Z</published>
    <updated>2019-10-20T10:05:08.451Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int small = prices[<span class="number">0</span>];</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            small = min(small, prices[i]);</span><br><span class="line">            res = max(prices[i]-small, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maxCur = <span class="number">0</span></span><br><span class="line">        maxSoFar = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(prices)):</span><br><span class="line">            maxCur += prices[i] - prices[i<span class="number">-1</span>] </span><br><span class="line">            maxCur = max(<span class="number">0</span>, maxCur)</span><br><span class="line">            maxSoFar = max(maxSoFar, maxCur)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxSoFar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/bes
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 33.Search in Rotated Sorted Array</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-33/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-33/</id>
    <published>2019-10-18T12:18:26.000Z</published>
    <updated>2019-10-18T12:20:11.077Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int l = <span class="number">0</span>, r = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            int m = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[l] &lt;= nums[m])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[m] &amp;&amp; target &gt;= nums[l])&#123;</span><br><span class="line">                    r = m<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    l = m+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt;= nums[r] &amp;&amp; target &gt; nums[m])&#123;</span><br><span class="line">                    l = m+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    r = m<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/search-in-rotated-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/sear
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 56. Merge Intervals</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-56/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-56/</id>
    <published>2019-10-18T12:15:38.000Z</published>
    <updated>2019-10-18T12:17:45.031Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-intervals/</a></p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(<span class="number">0</span>), end(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    static bool compare(Interval a, Interval b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.empty())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), compare);</span><br><span class="line">        </span><br><span class="line">        vector&lt;Interval&gt; res;</span><br><span class="line">        Interval temp(intervals[<span class="number">0</span>].start, intervals[<span class="number">0</span>].end);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.end &gt;= intervals[i].start)&#123;</span><br><span class="line">                temp.end = max(temp.end, intervals[i].end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(temp);</span><br><span class="line">                temp = intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res.push_back(temp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-intervals/&lt;/a
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 206. Reverse Linked List</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-206/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-206/</id>
    <published>2019-10-18T12:09:12.000Z</published>
    <updated>2019-10-18T12:14:03.213Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p><p>题意：反转链表</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(!head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode * ptr1, * ptr2, * ptr3;</span><br><span class="line">        ptr1 = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(ptr1)&#123;</span><br><span class="line">            ptr2 = ptr1-&gt;next;</span><br><span class="line">            ptr1-&gt;next = ptr3;</span><br><span class="line">            <span class="keyword">if</span>(!ptr2)&#123;</span><br><span class="line">                <span class="keyword">return</span> ptr1;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr3 = ptr1;</span><br><span class="line">            ptr1 = ptr2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ptr2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/reverse-linked-
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="List" scheme="https://wazxser.github.io/categories/Online-Judge/List/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 23. Merge k Sorted Lists</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-23/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-23/</id>
    <published>2019-10-18T12:02:34.000Z</published>
    <updated>2019-10-18T12:14:03.211Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><p>题意：合并k个已排好序的链表</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* temp = new ListNode(<span class="number">-1</span>);</span><br><span class="line">        temp-&gt;next = lists[0];</span><br><span class="line">        ListNode * ptr1, *ptr2, *ptr3; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; lists.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lists[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr1 = lists[i];</span><br><span class="line">            ptr2 = temp;</span><br><span class="line">            ptr3 = temp-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(ptr1 &amp;&amp; ptr3)&#123;</span><br><span class="line">                if(ptr1-&gt;val &lt;= ptr3-&gt;val)&#123;</span><br><span class="line">                    ListNode * temp2 = ptr1-&gt;next;</span><br><span class="line">                    </span><br><span class="line">                    ptr2-&gt;next = ptr1;</span><br><span class="line">                    ptr1-&gt;next = ptr3;</span><br><span class="line">                    ptr2 = ptr2-&gt;next;</span><br><span class="line">                    </span><br><span class="line">                    ptr1 = temp2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ptr3 = ptr3-&gt;next;</span><br><span class="line">                    ptr2 = ptr2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(ptr1)&#123;</span><br><span class="line">                ptr2-&gt;next = ptr1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-k-sorted-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/merge-k-sorted
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="List" scheme="https://wazxser.github.io/categories/Online-Judge/List/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 20. Valid Parentheses</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-20/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-20/</id>
    <published>2019-10-18T12:00:04.000Z</published>
    <updated>2019-10-18T12:14:03.206Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p><p>题意：括号匹配，栈的典型题</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">            <span class="keyword">elif</span> (stack[<span class="number">-1</span>] == <span class="string">'['</span> <span class="keyword">and</span> ch == <span class="string">']'</span>) <span class="keyword">or</span> (stack[<span class="number">-1</span>] == <span class="string">'&#123;'</span> <span class="keyword">and</span> ch == <span class="string">'&#125;'</span>) <span class="keyword">or</span> (stack[<span class="number">-1</span>] == <span class="string">'('</span> <span class="keyword">and</span> ch == <span class="string">')'</span>):</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(ch)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len(stack) &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/valid-parentheses
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="stack" scheme="https://wazxser.github.io/categories/Online-Judge/stack/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 21. Merge Two Sorted Lists</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-21/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-21/</id>
    <published>2019-10-18T11:57:26.000Z</published>
    <updated>2019-10-18T12:14:03.201Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/submissions/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/submissions/</a></p><p>题意：合并两个已经排好序的链表</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp = ListNode(<span class="number">0</span>)</span><br><span class="line">        temp.next = <span class="keyword">None</span></span><br><span class="line">        p = temp</span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                p.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            p.next = l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.next = l2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> temp.next</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="List" scheme="https://wazxser.github.io/categories/Online-Judge/List/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 53. Maximum Subarray</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-53/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-53/</id>
    <published>2019-10-18T11:55:23.000Z</published>
    <updated>2019-10-18T11:56:43.577Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p><p>题意：返回数组中连续和最大的和</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l = g = <span class="number">-10000000000000000</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            l = max(n,l+n)</span><br><span class="line">            g = max(l,g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-subarray/&lt;
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 15. 3Sum</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-15/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-15/</id>
    <published>2019-10-18T11:47:35.000Z</published>
    <updated>2019-10-18T11:50:27.002Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p><p>题意：求一个数组中，三个数字相加为0的组合，要求不能重复</p><p>思路：先排序，然后遍历查找，找剩下两个数字的时候，因为排序好了，所以分别从头尾一起查找</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            int a = i+<span class="number">1</span>; </span><br><span class="line">            int b = nums.size()<span class="number">-1</span>;</span><br><span class="line">            int target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">while</span>(a &lt; b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[a] + nums[b] == target)&#123;</span><br><span class="line">                    res.push_back(&#123;nums[i], nums[a], nums[b]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(nums[a+<span class="number">1</span>] == nums[a] &amp;&amp; a &lt; b)</span><br><span class="line">                        a++;</span><br><span class="line">                    <span class="keyword">while</span>(nums[b<span class="number">-1</span>] == nums[b] &amp;&amp; a &lt; b)</span><br><span class="line">                        b--;</span><br><span class="line">                    a++;</span><br><span class="line">                    b--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[a]+nums[b] &lt; target)&#123;</span><br><span class="line">                    a++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    b--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/3sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/3sum/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：求一个数组中，三个数
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 200. Number of Islands</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-200/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-200/</id>
    <published>2019-10-18T10:54:13.000Z</published>
    <updated>2019-10-18T11:39:55.099Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-islands/</a></p><p>题意：典型的DFS题目，题目给出一个由0和1组成的矩阵，0代表水，1代表陆地。求矩阵中小岛的个数。</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        int m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(i, j, grid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(int i, int j, vector&lt;vector&lt;char&gt;&gt; &amp; grid)&#123;</span><br><span class="line">        int m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            dfs(i<span class="number">-1</span>, j, grid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            dfs(i+<span class="number">1</span>, j, grid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            dfs(i, j<span class="number">-1</span>, grid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            dfs(i, j+<span class="number">1</span>, grid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/number-of-islands
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="DFS" scheme="https://wazxser.github.io/categories/Online-Judge/DFS/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 3. Longest Substring Without Repeating Characters</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-3/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-3/</id>
    <published>2019-10-18T10:48:35.000Z</published>
    <updated>2019-10-18T12:14:03.215Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><p>题意：给定一个字符串，返回这个字符串中最长的不包含重复字母的子串的长度</p><p>思路：设置一个数组记录每个字符出现的最后位置，left左指针到当前位置为滑动窗口</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int left = <span class="number">0</span>;</span><br><span class="line">        int last[<span class="number">255</span>];</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line">        memset(last, <span class="number">-1</span>, sizeof last);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last[s[i]] &gt;= left)&#123;</span><br><span class="line">                left = last[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last[s[i]] = i;</span><br><span class="line">            res = max(res, i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.c
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="string" scheme="https://wazxser.github.io/categories/Online-Judge/string/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 5. Longest Palindromic Substring</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-5/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-5/</id>
    <published>2019-10-18T08:43:44.000Z</published>
    <updated>2019-10-18T12:14:02.677Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><p>题意：搜索一个字符串中最长的回文序列</p><p>思路：回文序列的搜索以中间一个单独一个字母和中间两个相同字符分为两类</p><p>代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = <span class="number">0</span>, right = <span class="number">0</span>, index = <span class="number">0</span>, len = <span class="number">0</span>, wide = <span class="number">0</span>, res_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.length()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                index = searchPalindrome(s, i, i+<span class="number">1</span>, len);</span><br><span class="line">                <span class="keyword">if</span>(len &gt; wide)&#123;</span><br><span class="line">                    wide = len;</span><br><span class="line">                    res_index = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index = searchPalindrome(s, i, i, len);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(len &gt; wide)&#123;</span><br><span class="line">                wide = len;</span><br><span class="line">                res_index = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(res_index, wide);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int searchPalindrome(string s, int left, int right, int &amp;len)&#123;</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        int flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt; <span class="number">0</span> &amp;&amp; right &lt; s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">            left -= <span class="number">1</span>;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            len = right - left - <span class="number">1</span>;</span><br><span class="line">            index = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len = right - left + <span class="number">1</span>;</span><br><span class="line">            index = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/longe
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="string" scheme="https://wazxser.github.io/categories/Online-Judge/string/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 4. Median of Two Sorted Arrays</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-4/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-4/</id>
    <published>2019-10-18T07:58:42.000Z</published>
    <updated>2019-10-18T12:14:03.193Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p><p>这道题的题意是给定两个已经排好序的数组，求这两个数组所有数字的中位数，要求时间复杂度是O(log(m+n))的（应该自然想到<br>是二分法）</p><p>这道题感觉有点难，看了半天代码也看不懂是什么意思。。。，不过这样的题确实有意思。。。</p><p>思路： 在两个数组中找两个分解点i，j，保证0～i-1加0～j-1是两个数组的长度之和的一半，目标就是确定i和j的位置，使得<br>i-1位置数字也小于j位置数字（i-1位置数字保证小于i位置数字）和j-1位置数字小于i位置数字，这样0～i-1和0～j-1位置所有<br>数字都小于另一半部分的数字，中位数就是i-1和j-1位置数字的较大值和i位置和j位置数字的较小值的均值（两个数组所有数字<br>个数是偶数的话），或者i-1和j-1位置数字的较大值</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        int left = <span class="number">0</span>, right = m;</span><br><span class="line">        int i = <span class="number">-1</span>, j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(true)&#123;</span><br><span class="line">            i = (left + right) / <span class="number">2</span>;</span><br><span class="line">            j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((i == <span class="number">0</span> || j == n || nums1[i - <span class="number">1</span>] &lt;= nums2[j]) &amp;&amp; </span><br><span class="line">               (j == <span class="number">0</span> || i == m || nums2[j - <span class="number">1</span>] &lt;= nums1[i]))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])&#123;</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int max_left = <span class="number">-1</span>, min_right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            max_left = nums2[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">            max_left = nums1[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            max_left = max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((m+n) % <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max_left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i == m) </span><br><span class="line">            min_right = nums2[j];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == n) </span><br><span class="line">            min_right = nums1[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            min_right = min(nums1[i], nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> double(max_left + min_right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/median-
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="二分查找" scheme="https://wazxser.github.io/categories/Online-Judge/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 670. Maximum Swap</title>
    <link href="https://wazxser.github.io/2019/10/14/Leetcode-670/"/>
    <id>https://wazxser.github.io/2019/10/14/Leetcode-670/</id>
    <published>2019-10-14T05:21:41.000Z</published>
    <updated>2019-10-15T06:13:00.750Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-swap/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-swap/</a></p><p>num各位上的数字交换一次，使num达到能达到的最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumSwap(int num) &#123;</span><br><span class="line">        string str = to_string(num);</span><br><span class="line">        int res = num;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; str.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i + <span class="number">1</span>; j &lt; str.size(); j++)&#123;</span><br><span class="line">                swap(str[i], str[j]);</span><br><span class="line">                res = max(res, stoi(str));</span><br><span class="line">                swap(str[j], str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用一个数组记录num从低位开始到该位所有数字的最大值，然后从num的高位开始遍历，如果高位上数字小于数组中记录的数字，<br>就从低位查找到数组中记录的该数字的位置，然后进行交换返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumSwap(int num) &#123;</span><br><span class="line">        string str = to_string(num);</span><br><span class="line">        string arr = str;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = arr.size()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            arr[i] = max(arr[i], arr[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; arr[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(int j = str.size()<span class="number">-1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[j] == arr[i])&#123;</span><br><span class="line">                        swap(str[i], str[j]);</span><br><span class="line">                        <span class="keyword">return</span> stoi(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-swap/&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Online-Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 958 Check Completeness of a Binary Tree</title>
    <link href="https://wazxser.github.io/2019/10/13/Leetcode-958/"/>
    <id>https://wazxser.github.io/2019/10/13/Leetcode-958/</id>
    <published>2019-10-13T07:02:23.000Z</published>
    <updated>2019-10-18T12:14:03.208Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/check-completeness-of-a-binary-tree/</a></p><p>这道题比较简单，利用树的层序遍历，当第一次遇到空节点时，设置flag，如果第二次再遇到，那就返回false。</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isCompleteTree(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode * temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!temp)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/check-completeness-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
      <category term="Tree" scheme="https://wazxser.github.io/categories/Online-Judge/Tree/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 470 Implement Rand10() Using Rand7()</title>
    <link href="https://wazxser.github.io/2019/10/13/Leetcode-470/"/>
    <id>https://wazxser.github.io/2019/10/13/Leetcode-470/</id>
    <published>2019-10-13T02:44:33.000Z</published>
    <updated>2019-10-13T02:57:40.803Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-rand10-using-rand7/</a></p><p>随机数的产生关键是等概率，这里有一个概念是拒绝采样，例如rand7()，等概率产生1～7的随机数，如果想要等概率得到1～5的数字，<br>就不断rand7()，如果产生6,7就拒绝，如果是1～5范围内就接受。这样产生的数字在1到5范围内也是等概率的。</p><p>一些例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand4()： (rand2() - <span class="number">1</span>) × <span class="number">2</span> + rand2()</span><br><span class="line">rand2(): rand4() % <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">         rand6() % <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// The rand7() API <span class="keyword">is</span> already defined <span class="keyword">for</span> you.</span><br><span class="line">// int rand7();</span><br><span class="line">// @<span class="keyword">return</span> a random integer <span class="keyword">in</span> the range <span class="number">1</span> to <span class="number">7</span></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rand10() &#123;</span><br><span class="line">        int val5, val6;</span><br><span class="line">        <span class="keyword">while</span>((val6 = rand7()) &gt; <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">while</span>((val5 = rand7()) &gt; <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> (val6 % <span class="number">2</span>) * <span class="number">5</span> + val5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/implement-rand10-using-rand7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/implem
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>ODD papers reading</title>
    <link href="https://wazxser.github.io/2019/09/18/odd-papers-reading/"/>
    <id>https://wazxser.github.io/2019/09/18/odd-papers-reading/</id>
    <published>2019-09-18T14:19:01.000Z</published>
    <updated>2019-10-09T10:55:10.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>目前大部分论文都是用和原始模型训练集不同的数据集来作为out of distribution的数据集，。<br>OOD——out of distribution<br>ODD——out of distribution detection<br>ID——in distribution<br>ODD也称作： one-class classification, novelty detection, anomaly detection, outlier detection, selective prediction, open set recognition,</p><h1 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h1><ul><li>AUROC（Aera Under Receiver of Characters curve）：受试工作者特征曲线下的面积，ROC曲线的纵坐标是TPR (TP/TP+FN)，横坐标是FPR (FP/FP+TN)</li><li>AUPR （Aera Under the Precision-Recall curve）：precision~recall</li><li>FPR$N$：当有$N\%$的OOD样本被检测出来时，一个ID样本被检测错的概率，越低越好。</li></ul><h2 id="Deep-anomaly-detection-with-outlier-exposure"><a href="#Deep-anomaly-detection-with-outlier-exposure" class="headerlink" title="Deep anomaly detection with outlier exposure"></a><a href="https://arxiv.org/abs/1812.04606v3" target="_blank" rel="noopener">Deep anomaly detection with outlier exposure</a></h2><p>(ICLR’2019) <strong>Dan Hendrycks, Mantas Mazeika, Thomas G. Dietterich</strong></p><ul><li>主要内容：<ul><li>在一些现有的ODD detectors上增加Outlier Exposure机制，设计了一个损失函数，帮助提高OOD检测的准确率<br>$$\mathbb{E} _ {(x, y) \sim \mathcal{D} _ {in}} [ \mathcal{L} (f(x), y) + \lambda \mathbb{E} _ {x^{\prime} \sim \mathcal{D} _ {out}^{OE}} [ \mathcal{L}_{OE} (f(x^{\prime}), f(x), y) ] ]$$</li><li>在baseline方法Maximum Softmax Probability、Confidence Branch和Density estimators增加了关于OOD样本的损失项，使得原有的detectors增强了检测OOD样本的能力。</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/hendrycks/outlier-exposure" target="_blank" rel="noopener">https://github.com/hendrycks/outlier-exposure</a><ul><li>在图片和文本数据集上进行实验 </li></ul></li></ul><h2 id="A-baseline-for-detecting-misclassified-and-out-of-distribution-examples-in-neural-networks"><a href="#A-baseline-for-detecting-misclassified-and-out-of-distribution-examples-in-neural-networks" class="headerlink" title="A baseline for detecting misclassified and out-of-distribution examples in neural networks"></a><a href="https://arxiv.org/abs/1610.02136" target="_blank" rel="noopener">A baseline for detecting misclassified and out-of-distribution examples in neural networks</a></h2><p>(ICLR’17) <strong>Dan Hendrycks, Kevin Gimpel</strong></p><ul><li>主要内容：<ul><li>利用softmax给出的信心值作为判断样本是否是OOD的依据</li><li>高置信度的错误预测经常是来自于softmax的，单从某个样本上看，softmax给的信心值可能是错的，但是从统计上看，错误分类的样本<br>和OOD的样本在softmax给出的信心值上是比正常的正确分类的样本是要低的。</li></ul></li><li>代码实现（Tensorflow）：<a href="https://github.com/hendrycks/error-detection" target="_blank" rel="noopener">https://github.com/hendrycks/error-detection</a></li></ul><h2 id="Training-confidence-calibrated-classifiers-for-detecting-out-of-distribution-samples"><a href="#Training-confidence-calibrated-classifiers-for-detecting-out-of-distribution-samples" class="headerlink" title="Training confidence-calibrated classifiers for detecting out-of-distribution samples"></a><a href="https://arxiv.org/abs/1711.09325" target="_blank" rel="noopener">Training confidence-calibrated classifiers for detecting out-of-distribution samples</a></h2><p>(ICLR’18) <strong>Kimin Lee, Honglak Lee, Kibok Lee, Jinwoo Shin</strong></p><ul><li><p>主要内容：</p><ul><li>在原有模型的训练中，设计了一个新的损失函数（confidence loss）如下，如果样本是OOD的，预测输出的信心值趋近于一个常数值（如，0），如果样本是ID的，则是一般的预测信心值。<br>$$\mathop{min}\limits_{\theta} \ \mathbb{E}_{P_{in} (\hat{x}, \hat{y}) } \ [-logP_{\theta}(y = \hat{y}|\hat{\mathbf{x}}) ] + \beta \mathbb{E}_{P_{out} (\mathbf{x})} \lbrack KL(\mathcal{U}(y) \Vert P_{\theta}(y|\mathbf{x})) \rbrack $$</li><li>训练一个generator网络，用来生成OOD的样本，并且尽可能与ID样本是相近的<br>$$\mathop{min}\limits_{G} \mathop{max}\limits_{D} \ \beta \mathbb{E}_{P_{G(\mathbf{x})}} [ KL (\mathcal(y) || P_{\theta}(y | \mathbf{x})) ] + \mathbb{E}_{P_{in(\mathbf{x})}} [ \mathop{log} D(\mathbf{x}) ] + \mathbb{E}_{P_{G(\mathbf{x})}} [ \mathop{log} (1 - D(\mathbf{x}) ) ]$$</li><li>使用自定义的损失函数，交替训练原始网络和GAN至收敛。</li></ul></li><li><p>代码实现（Pytorch）：<a href="https://github.com/alinlab/Confident_classifier" target="_blank" rel="noopener">https://github.com/alinlab/Confident_classifier</a></p></li></ul><h2 id="Learning-Confidence-for-Out-of-Distribution-Detection-in-Neural-Networks"><a href="#Learning-Confidence-for-Out-of-Distribution-Detection-in-Neural-Networks" class="headerlink" title="Learning Confidence for Out-of-Distribution Detection in Neural Networks"></a><a href="https://arxiv.org/abs/1802.04865" target="_blank" rel="noopener">Learning Confidence for Out-of-Distribution Detection in Neural Networks</a></h2><p>(‘18) <strong>Terrance DeVries, Graham W. Taylor</strong></p><ul><li>主要内容：<ul><li>在网络的penultimate layer之后增加一个用来显示模型对样本分类信心程度大小的一个模块。</li><li>用单层或者多层的全连结神经网络来实现</li><li>设计的损失函数为<br>$$\mathcal{L} = - \sum_{i=1}^{M} log (p_i^{\prime})y_i + - \lambda log (c)$$</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/uoguelph-mlrg/confidence_estimation" target="_blank" rel="noopener">https://github.com/uoguelph-mlrg/confidence_estimation</a></li></ul><h2 id="Enhancing-The-Reliability-of-Out-of-distribution-Image-Detection-in-Neural-Networks"><a href="#Enhancing-The-Reliability-of-Out-of-distribution-Image-Detection-in-Neural-Networks" class="headerlink" title="Enhancing The Reliability of Out-of-distribution Image Detection in Neural Networks"></a><a href="https://arxiv.org/abs/1706.02690" target="_blank" rel="noopener">Enhancing The Reliability of Out-of-distribution Image Detection in Neural Networks</a></h2><p>(ICLR’18) <strong>Shiyu Liang, Yixuan Li, R. Srikant</strong></p><ul><li><p>主要内容：</p><ul><li>在使用的softmax做为ID和OOD样本分类的基础上，增加了temp scaling和在input perturbing的机制。</li><li>Tempperature Scaling:<br>$$S _ {i} (\mathbf{x}; T) = \frac{exp(f_i(\mathbf{x})/ T)}{\sum _ {j = 1} ^ {N} exp (f_j(\mathbf{x})/T)}$$</li><li>Input perturbing:<br>$$\tilde{x} = x - \varepsilon sign (-\nabla _ {x} log S_{\tilde{y}} (\mathbf{x};T)) $$</li></ul></li><li><p>代码实现（Pytorch）：<a href="https://github.com/facebookresearch/odin" target="_blank" rel="noopener">https://github.com/facebookresearch/odin</a></p></li></ul><h2 id="Out-of-Distribution-Detection-using-Multiple-Semantic-Label-Representations"><a href="#Out-of-Distribution-Detection-using-Multiple-Semantic-Label-Representations" class="headerlink" title="Out-of-Distribution Detection using Multiple Semantic Label Representations"></a><a href="https://arxiv.org/abs/1808.06664" target="_blank" rel="noopener">Out-of-Distribution Detection using Multiple Semantic Label Representations</a></h2><p>(NeurIPS’18) <strong>Gabi Shalev, Yossi Adi, Joseph Keshet</strong></p><ul><li>主要内容：<ul><li>在深度神经网络之后接入K个回归函数，输出K个不同词向量</li><li>用词向量之间的$L_2$范数距离做为衡量OOD样本的标准</li></ul></li><li>代码实现： <a href="https://github.com/MLSpeech/semantic_OOD（代码仓库是空的。。。）" target="_blank" rel="noopener">https://github.com/MLSpeech/semantic_OOD（代码仓库是空的。。。）</a></li></ul><h2 id="A-Simple-Unified-Framework-for-Detecting-Out-of-Distribution-Samples-and-Adversarial-Attacks"><a href="#A-Simple-Unified-Framework-for-Detecting-Out-of-Distribution-Samples-and-Adversarial-Attacks" class="headerlink" title="A Simple Unified Framework for Detecting Out-of-Distribution Samples and Adversarial Attacks"></a><a href="https://arxiv.org/abs/1807.03888" target="_blank" rel="noopener">A Simple Unified Framework for Detecting Out-of-Distribution Samples and Adversarial Attacks</a></h2><p>(NeurIPS’18) <strong>Kimin Lee, Kibok Lee, Honglak Lee, Jinwoo Shin</strong></p><ul><li>主要内容：<ul><li>用于OOD样本检测和对抗样本检测</li><li>通过类条件高斯分布来表示每个类别的样本的特征的分布（这个有近似的理论依据），$f(\cdot)$为DNN的penultimate layer的输出。<br>$$P(f(\mathbf{x}) | y = c) = \mathcal{N} (f(\mathbf{x}) | \mu _ {c}, \Sigma)$$</li><li>通过计算待测样本和距离最近的类条件高斯分布之间的马式距离来作为ODD score。</li><li>通过在待测样本上增加扰动（在score增加的方向上）来使得ID样本和OOD样本区别更大</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/pokaxpoka/deep_Mahalanobis_detector" target="_blank" rel="noopener">https://github.com/pokaxpoka/deep_Mahalanobis_detector</a> </li></ul><h2 id="How-to-know-when-machine-learning-does-not-know"><a href="#How-to-know-when-machine-learning-does-not-know" class="headerlink" title="How to know when machine learning does not know"></a><a href="http://www.cleverhans.io/security/2019/05/20/dknn.html" target="_blank" rel="noopener">How to know when machine learning does not know</a></h2><p>(cleverhans blog by Nicolas Papernot and Nicholas Frosst)</p><ul><li>主要内容：<ul><li>提取样本在神经网络中每一层的输出特征</li><li>在每一层的输出中，用k近邻找出与测试样本最相近的k个训练集中的样本</li><li>根据测试样本和找出训练样本的分类结果的差异来判断测试样本是否是OOD的</li></ul></li><li>代码实现：<a href="https://github.com/rodgzilla/machine_learning_deep_knn" target="_blank" rel="noopener">https://github.com/rodgzilla/machine_learning_deep_knn</a></li></ul><h2 id="Deep-One-Class-Classification"><a href="#Deep-One-Class-Classification" class="headerlink" title="Deep One-Class Classification"></a><a href="http://proceedings.mlr.press/v80/ruff18a.html" target="_blank" rel="noopener">Deep One-Class Classification</a></h2><p>(ICML’18) <strong>Lukas Ruff, Robert Vandermeulen, Nico Goernitz, Lucas Deecke, Shoaib Ahmed Siddiqui, Alexander Binder, Emmanuel Müller, Marius Kloft</strong></p><ul><li>主要内容：<ul><li>深度支持向量数据描述。。。将OOD样本的检测问题视为一个二分类问题，这方面研究还有很多工作，One-Class SVM（OC-SVM），编码解码器，GAN之类的。</li><li>目标是学习一个训练集数据的描述，用神经网络表示为一个超球，这个超球尽可能小地只包含ID样本，如果样本落在超球内，是ID样本，如果落在外面是，OOD样本。</li><li></li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/lukasruff/Deep-SVDD" target="_blank" rel="noopener">https://github.com/lukasruff/Deep-SVDD</a><ul><li>做实验时，使用数据集中的一类样本做为ID的，其他类样本为OOD的</li><li>能检测对抗样本</li></ul></li></ul><h2 id="Deep-autoencoding-gaussian-mixture-model-for-unsupervised-anomaly-detection"><a href="#Deep-autoencoding-gaussian-mixture-model-for-unsupervised-anomaly-detection" class="headerlink" title="Deep autoencoding gaussian mixture model for unsupervised anomaly detection"></a><a href="https://openreview.net/forum?id=BJJLHbb0-" target="_blank" rel="noopener">Deep autoencoding gaussian mixture model for unsupervised anomaly detection</a></h2><p>(ICLR’18) <strong>Bo Zong, Qi Song, Martin Renqiang Min, Wei Cheng, Cristian Lumezanu, Daeki Cho, Haifeng Chen</strong></p><ul><li>主要内容：<ul><li>深度自动编码的高斯混合模型，无监督的异常检测问题</li><li>利用深度解码器来对输入进行降维</li><li>利用高斯混合模型通过density estimation来估计每个样本的是否是OOD的分数</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/danieltan07/dagmm" target="_blank" rel="noopener">https://github.com/danieltan07/dagmm</a> （Tensorflow）：<a href="https://github.com/Newcomer520/tf-dagmm" target="_blank" rel="noopener">https://github.com/Newcomer520/tf-dagmm</a><ul><li>OODS datasets：<a href="http://odds.cs.stonybrook.edu/" target="_blank" rel="noopener">http://odds.cs.stonybrook.edu/</a></li></ul></li></ul><h2 id="Anomaly-Detection-with-Generative-Adversarial-Networks"><a href="#Anomaly-Detection-with-Generative-Adversarial-Networks" class="headerlink" title="Anomaly Detection with Generative Adversarial Networks"></a><a href="https://arxiv.org/abs/1703.05921" target="_blank" rel="noopener">Anomaly Detection with Generative Adversarial Networks</a></h2><p>(IPMI’17) <strong>Thomas Schlegl, Philipp Seeböck, Sebastian M. Waldstein, Ursula Schmidt-Erfurth, Georg Langs</strong></p><ul><li>主要内容：<ul><li>通过GAN来学习</li><li>设计一种评价机制来给出样本一个分数做为判断是否是OOD的标准。</li></ul></li><li>代码实现：</li></ul><h2 id="Novelty-Detection-with-GAN"><a href="#Novelty-Detection-with-GAN" class="headerlink" title="Novelty Detection with GAN"></a><a href="https://arxiv.org/abs/1802.10560" target="_blank" rel="noopener">Novelty Detection with GAN</a></h2><p>(‘18) <strong>Mark Kliger, Shachar Fleishman</strong></p><ul><li>主要内容：<ul><li>使用原始训练集和其他分布的数据来训练generator</li><li>使得discriminator能够识别出OOD的样本</li></ul></li><li>代码实现：</li></ul><h2 id="Out-of-distribution-detection-using-an-ensemble-of-self-supervised-leave-out-classifiers"><a href="#Out-of-distribution-detection-using-an-ensemble-of-self-supervised-leave-out-classifiers" class="headerlink" title="Out-of-distribution detection using an ensemble of self supervised leave-out classifiers"></a><a href="https://arxiv.org/abs/1809.03576" target="_blank" rel="noopener">Out-of-distribution detection using an ensemble of self supervised leave-out classifiers</a></h2><p>(ECCV’18) <strong>Apoorv Vyas, Nataraj Jammalamadaka, Xia Zhu, Dipankar Das, Bharat Kaul, Theodore L. Willke</strong></p><ul><li>主要内容：<ul><li>使用集成的方法来判断样本是否是OOD的</li><li>每个分类器都是通过留出法来训练的</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/YU1ut/Ensemble-of-Leave-out-Classifiers" target="_blank" rel="noopener">https://github.com/YU1ut/Ensemble-of-Leave-out-Classifiers</a></li></ul><h2 id="Reducing-Network-Agnostophobia"><a href="#Reducing-Network-Agnostophobia" class="headerlink" title="Reducing Network Agnostophobia"></a><a href="https://arxiv.org/abs/1811.04110v2" target="_blank" rel="noopener">Reducing Network Agnostophobia</a></h2><p>(NeurIPS’18) <strong>Akshay Raj Dhamija, Manuel Günther, Terrance E. Boult</strong></p><ul><li>主要内容：<ul><li>Agnostophobia：未知的恐惧</li></ul></li><li>代码实现（Keras）：<a href="https://github.com/Vastlab/Reducing-Network-Agnostophobia" target="_blank" rel="noopener">https://github.com/Vastlab/Reducing-Network-Agnostophobia</a></li></ul><h2 id="Classification-Reconstruction-Learning-for-Open-Set-Recognition"><a href="#Classification-Reconstruction-Learning-for-Open-Set-Recognition" class="headerlink" title="Classification-Reconstruction Learning for Open-Set Recognition"></a><a href="https://arxiv.org/abs/1812.04246?context=cs" target="_blank" rel="noopener">Classification-Reconstruction Learning for Open-Set Recognition</a></h2><p>(‘18) <strong>Ryota Yoshihashi, Wen Shao, Rei Kawakami, Shaodi You, Makoto Iida, Takeshi Naemura</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现：</li></ul><h2 id="On-the-Foundations-of-Noise-free-Selective-Classification"><a href="#On-the-Foundations-of-Noise-free-Selective-Classification" class="headerlink" title="On the Foundations of Noise-free Selective Classification"></a><a href="http://jmlr.org/papers/volume11/el-yaniv10a/el-yaniv10a.pdf" target="_blank" rel="noopener">On the Foundations of Noise-free Selective Classification</a></h2><p><strong>El-Yaniv, Ran，YairWiener</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现：</li></ul><h2 id="Selective-Classification-for-Deep-Neural-Networks"><a href="#Selective-Classification-for-Deep-Neural-Networks" class="headerlink" title="Selective Classification for Deep Neural Networks"></a><a href="http://papers.nips.cc/paper/7073-selective-classification-for-deep-neural-networks" target="_blank" rel="noopener">Selective Classification for Deep Neural Networks</a></h2><p>(NeurIPS’17) <strong>Yonatan Geifman, Ran El-Yaniv</strong></p><ul><li>主要内容：<ul><li>在原始网络的基础上再训练一个selective classifier</li><li>允许用户设置期望的风险水平</li><li></li></ul></li><li>代码实现：</li></ul><h2 id="To-Trust-Or-Not-To-Trust-A-Classifier"><a href="#To-Trust-Or-Not-To-Trust-A-Classifier" class="headerlink" title="To Trust Or Not To Trust A Classifier"></a><a href="https://arxiv.org/abs/1805.11783v2" target="_blank" rel="noopener">To Trust Or Not To Trust A Classifier</a></h2><p>(NeurIPS’18) <strong>Heinrich Jiang, Been Kim, Melody Y. Guan, Maya Gupta</strong></p><ul><li>主要内容：<ul><li>设计一种评分标准，分数高则认为分类器结果哦可信任，低则不可信任</li><li>分数为，测试样本到除了预测分类以外，其他分类中距离最近样本的距离和测试样本到预测分类样本的距离</li></ul></li><li>代码实现： <a href="https://github.com/google/TrustScore" target="_blank" rel="noopener">https://github.com/google/TrustScore</a></li></ul><h2 id="Simple-and-Scalable-Predictive-Uncertainty-Estimation-using-Deep-Ensembles"><a href="#Simple-and-Scalable-Predictive-Uncertainty-Estimation-using-Deep-Ensembles" class="headerlink" title="Simple and Scalable Predictive Uncertainty Estimation using Deep Ensembles"></a><a href="https://arxiv.org/abs/1612.01474" target="_blank" rel="noopener">Simple and Scalable Predictive Uncertainty Estimation using Deep Ensembles</a></h2><p>(NeurIPS’17) <strong>Balaji Lakshminarayanan, Alexander Pritzel, Charles Blundell</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（Tensorflow）：<a href="https://github.com/vvanirudh/deep-ensembles-uncertainty" target="_blank" rel="noopener">https://github.com/vvanirudh/deep-ensembles-uncertainty</a></li></ul><h2 id="Open-Category-Detection-with-PAC-Guarantees"><a href="#Open-Category-Detection-with-PAC-Guarantees" class="headerlink" title="Open Category Detection with PAC Guarantees"></a><a href="https://arxiv.org/abs/1808.00529" target="_blank" rel="noopener">Open Category Detection with PAC Guarantees</a></h2><p>(ICML’18) <strong>Si Liu, Risheek Garrepalli, Thomas G. Dietterich, Alan Fern, Dan Hendrycks</strong></p><ul><li>代码实现（R）：<a href="https://github.com/liusi2019/ocd" target="_blank" rel="noopener">https://github.com/liusi2019/ocd</a></li></ul><h2 id="Metric-Learning-for-Novelty-and-Anomaly-Detection"><a href="#Metric-Learning-for-Novelty-and-Anomaly-Detection" class="headerlink" title="Metric Learning for Novelty and Anomaly Detection"></a><a href="https://arxiv.org/abs/1808.05492" target="_blank" rel="noopener">Metric Learning for Novelty and Anomaly Detection</a></h2><p>(BMVC’18) <strong>Marc Masana, Idoia Ruiz, Joan Serrat, Joost van de Weijer, Antonio M. Lopez</strong></p><ul><li>代码实现（Tensorflow）：<a href="https://mmasana.github.io/OoD_Mining/" target="_blank" rel="noopener">https://mmasana.github.io/OoD_Mining/</a></li></ul><h2 id="WAIC-but-Why-Generative-Ensembles-for-Robust-Anomaly-Detection"><a href="#WAIC-but-Why-Generative-Ensembles-for-Robust-Anomaly-Detection" class="headerlink" title="WAIC, but Why? Generative Ensembles for Robust Anomaly Detection"></a><a href="https://arxiv.org/abs/1810.01392" target="_blank" rel="noopener">WAIC, but Why? Generative Ensembles for Robust Anomaly Detection</a></h2><p>(‘18) <strong>Hyunsun Choi, Eric Jang, Alexander A. Alemi</strong></p><ul><li>主要内容：<ul><li>WAIC：估计训练集和测试集数据期望之间的差距</li></ul></li><li>代码实现： </li></ul><h2 id="Towards-open-world-recognition"><a href="#Towards-open-world-recognition" class="headerlink" title="Towards open world recognition"></a><a href="https://arxiv.org/abs/1412.5687" target="_blank" rel="noopener">Towards open world recognition</a></h2><p>(CVPR’15) <strong>Abhijit Bendale, Terrance Boult</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（MATLAB）：<a href="https://github.com/abhijitbendale/OWR" target="_blank" rel="noopener">https://github.com/abhijitbendale/OWR</a></li></ul><h2 id="Anomaly-Detection-using-One-Class-Neural-Networks"><a href="#Anomaly-Detection-using-One-Class-Neural-Networks" class="headerlink" title="Anomaly Detection using One-Class Neural Networks"></a><a href="https://arxiv.org/abs/1802.06360" target="_blank" rel="noopener">Anomaly Detection using One-Class Neural Networks</a></h2><p>(‘18) <strong>Raghavendra Chalapathy, Aditya Krishna Menon, Sanjay Chawla</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（）：</li></ul><h2 id="Figure-of-Merit-Training-for-Detection-and-Spotting"><a href="#Figure-of-Merit-Training-for-Detection-and-Spotting" class="headerlink" title="Figure of Merit Training for Detection and Spotting"></a><a href="http://papers.nips.cc/paper/792-figure-of-merit-training-for-detection-and-spotting" target="_blank" rel="noopener">Figure of Merit Training for Detection and Spotting</a></h2><p>(NeurIPS’93) <strong>Eric I. Chang and Richard P. Lippmann</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现：</li></ul><h2 id="Towards-Open-Set-Deep-Networks"><a href="#Towards-Open-Set-Deep-Networks" class="headerlink" title="Towards Open Set Deep Networks"></a><a href="https://arxiv.org/abs/1511.06233" target="_blank" rel="noopener">Towards Open Set Deep Networks</a></h2><p>(CVPR’16) <strong>Abhijit Bendale, Terrance Boult</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（caffe）： <a href="https://github.com/abhijitbendale/OSDN" target="_blank" rel="noopener">https://github.com/abhijitbendale/OSDN</a>  （keras）<a href="https://github.com/aadeshnpn/OSDN" target="_blank" rel="noopener">https://github.com/aadeshnpn/OSDN</a></li></ul><h2 id="A-loss-framework-for-calibrated-anomaly-detection"><a href="#A-loss-framework-for-calibrated-anomaly-detection" class="headerlink" title="A loss framework for calibrated anomaly detection"></a><a href="http://papers.nips.cc/paper/7422-a-loss-framework-for-calibrated-anomaly-detection" target="_blank" rel="noopener">A loss framework for calibrated anomaly detection</a></h2><p>(NeurIPS’18) <strong>Aditya Krishna Menon, Robert C. Williamson</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（）：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;p&gt;目前大部分论文都是用和原始模型训练集不同的数据集来作为out of distribution的数据集
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode_137_Single_Number_II</title>
    <link href="https://wazxser.github.io/2019/04/29/leetcode-137-Single-Number-II/"/>
    <id>https://wazxser.github.io/2019/04/29/leetcode-137-Single-Number-II/</id>
    <published>2019-04-29T13:56:38.000Z</published>
    <updated>2019-04-29T14:08:41.798Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/</a></p><p>感觉这道题好有意思。题目大意为：给一个数组，数组中除了一个数字出现一次外，其他数字均出现<br>三次，找出这个出现一次的数字。</p><p>思路：从网上看的题解，利用位运算，记录整数的二进制表示中每一位1出现的次数。</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            ones = (nums[i] ^ ones) &amp; ~twos;</span><br><span class="line">            twos = (nums[i] ^ twos) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number-ii/&lt;
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
