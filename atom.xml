<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Moon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wazxser.github.io/"/>
  <updated>2019-10-18T10:51:54.527Z</updated>
  <id>https://wazxser.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 3. Longest Substring Without Repeating Characters</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-3/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-3/</id>
    <published>2019-10-18T10:48:35.000Z</published>
    <updated>2019-10-18T10:51:54.527Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><p>题意：给定一个字符串，返回这个字符串中最长的不包含重复字母的子串的长度</p><p>思路：设置一个数组记录每个字符出现的最后位置，left左指针到当前位置为滑动窗口</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int left = <span class="number">0</span>;</span><br><span class="line">        int last[<span class="number">255</span>];</span><br><span class="line">        int res = <span class="number">0</span>;</span><br><span class="line">        memset(last, <span class="number">-1</span>, sizeof last);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(last[s[i]] &gt;= left)&#123;</span><br><span class="line">                left = last[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last[s[i]] = i;</span><br><span class="line">            res = max(res, i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.c
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 5. Longest Palindromic Substring</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-5/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-5/</id>
    <published>2019-10-18T08:43:44.000Z</published>
    <updated>2019-10-18T08:46:20.718Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></p><p>题意：搜索一个字符串中最长的回文序列</p><p>思路：回文序列的搜索以中间一个单独一个字母和中间两个相同字符分为两类</p><p>代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = <span class="number">0</span>, right = <span class="number">0</span>, index = <span class="number">0</span>, len = <span class="number">0</span>, wide = <span class="number">0</span>, res_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.length()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                index = searchPalindrome(s, i, i+<span class="number">1</span>, len);</span><br><span class="line">                <span class="keyword">if</span>(len &gt; wide)&#123;</span><br><span class="line">                    wide = len;</span><br><span class="line">                    res_index = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index = searchPalindrome(s, i, i, len);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(len &gt; wide)&#123;</span><br><span class="line">                wide = len;</span><br><span class="line">                res_index = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substr(res_index, wide);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int searchPalindrome(string s, int left, int right, int &amp;len)&#123;</span><br><span class="line">        int index = <span class="number">0</span>;</span><br><span class="line">        int flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt; <span class="number">0</span> &amp;&amp; right &lt; s.length()<span class="number">-1</span>)&#123;</span><br><span class="line">            left -= <span class="number">1</span>;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)&#123;</span><br><span class="line">            len = right - left - <span class="number">1</span>;</span><br><span class="line">            index = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len = right - left + <span class="number">1</span>;</span><br><span class="line">            index = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/longe
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 4. Median of Two Sorted Arrays</title>
    <link href="https://wazxser.github.io/2019/10/18/Leetcode-4/"/>
    <id>https://wazxser.github.io/2019/10/18/Leetcode-4/</id>
    <published>2019-10-18T07:58:42.000Z</published>
    <updated>2019-10-18T08:12:01.695Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p><p>这道题的题意是给定两个已经排好序的数组，求这两个数组所有数字的中位数，要求时间复杂度是O(log(m+n))的（应该自然想到<br>是二分法）</p><p>这道题感觉有点难，看了半天代码也看不懂是什么意思。。。，不过这样的题确实有意思。。。</p><p>思路： 在两个数组中找两个分解点i，j，保证0～i-1加0～j-1是两个数组的长度之和的一半，目标就是确定i和j的位置，使得<br>i-1位置数字也小于j位置数字（i-1位置数字保证小于i位置数字）和j-1位置数字小于i位置数字，这样0～i-1和0～j-1位置所有<br>数字都小于另一半部分的数字，中位数就是i-1和j-1位置数字的较大值和i位置和j位置数字的较小值的均值（两个数组所有数字<br>个数是偶数的话），或者i-1和j-1位置数字的较大值</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        </span><br><span class="line">        int left = <span class="number">0</span>, right = m;</span><br><span class="line">        int i = <span class="number">-1</span>, j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(true)&#123;</span><br><span class="line">            i = (left + right) / <span class="number">2</span>;</span><br><span class="line">            j = (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((i == <span class="number">0</span> || j == n || nums1[i - <span class="number">1</span>] &lt;= nums2[j]) &amp;&amp; </span><br><span class="line">               (j == <span class="number">0</span> || i == m || nums2[j - <span class="number">1</span>] &lt;= nums1[i]))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums1[i<span class="number">-1</span>] &gt; nums2[j])&#123;</span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; nums2[j<span class="number">-1</span>] &gt; nums1[i])&#123;</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int max_left = <span class="number">-1</span>, min_right = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            max_left = nums2[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">            max_left = nums1[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            max_left = max(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((m+n) % <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> max_left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i == m) </span><br><span class="line">            min_right = nums2[j];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == n) </span><br><span class="line">            min_right = nums1[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            min_right = min(nums1[i], nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> double(max_left + min_right) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/median-
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 670. Maximum Swap</title>
    <link href="https://wazxser.github.io/2019/10/14/Leetcode-670/"/>
    <id>https://wazxser.github.io/2019/10/14/Leetcode-670/</id>
    <published>2019-10-14T05:21:41.000Z</published>
    <updated>2019-10-15T06:13:00.750Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/maximum-swap/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-swap/</a></p><p>num各位上的数字交换一次，使num达到能达到的最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumSwap(int num) &#123;</span><br><span class="line">        string str = to_string(num);</span><br><span class="line">        int res = num;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; str.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j = i + <span class="number">1</span>; j &lt; str.size(); j++)&#123;</span><br><span class="line">                swap(str[i], str[j]);</span><br><span class="line">                res = max(res, stoi(str));</span><br><span class="line">                swap(str[j], str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用一个数组记录num从低位开始到该位所有数字的最大值，然后从num的高位开始遍历，如果高位上数字小于数组中记录的数字，<br>就从低位查找到数组中记录的该数字的位置，然后进行交换返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maximumSwap(int num) &#123;</span><br><span class="line">        string str = to_string(num);</span><br><span class="line">        string arr = str;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = arr.size()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            arr[i] = max(arr[i], arr[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; str.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; arr[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(int j = str.size()<span class="number">-1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str[j] == arr[i])&#123;</span><br><span class="line">                        swap(str[i], str[j]);</span><br><span class="line">                        <span class="keyword">return</span> stoi(str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-swap/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/maximum-swap/&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Online-Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 958 Check Completeness of a Binary Tree</title>
    <link href="https://wazxser.github.io/2019/10/13/Leetcode-958/"/>
    <id>https://wazxser.github.io/2019/10/13/Leetcode-958/</id>
    <published>2019-10-13T07:02:23.000Z</published>
    <updated>2019-10-14T01:45:04.396Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/check-completeness-of-a-binary-tree/</a></p><p>这道题比较简单，利用树的层序遍历，当第一次遇到空节点时，设置flag，如果第二次再遇到，那就返回false。</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isCompleteTree(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            TreeNode * temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!temp)&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> false;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/check-completeness-of-a-binary-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 470 Implement Rand10() Using Rand7()</title>
    <link href="https://wazxser.github.io/2019/10/13/Leetcode-470/"/>
    <id>https://wazxser.github.io/2019/10/13/Leetcode-470/</id>
    <published>2019-10-13T02:44:33.000Z</published>
    <updated>2019-10-13T02:57:40.803Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">https://leetcode.com/problems/implement-rand10-using-rand7/</a></p><p>随机数的产生关键是等概率，这里有一个概念是拒绝采样，例如rand7()，等概率产生1～7的随机数，如果想要等概率得到1～5的数字，<br>就不断rand7()，如果产生6,7就拒绝，如果是1～5范围内就接受。这样产生的数字在1到5范围内也是等概率的。</p><p>一些例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rand4()： (rand2() - <span class="number">1</span>) × <span class="number">2</span> + rand2()</span><br><span class="line">rand2(): rand4() % <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">         rand6() % <span class="number">2</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// The rand7() API <span class="keyword">is</span> already defined <span class="keyword">for</span> you.</span><br><span class="line">// int rand7();</span><br><span class="line">// @<span class="keyword">return</span> a random integer <span class="keyword">in</span> the range <span class="number">1</span> to <span class="number">7</span></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rand10() &#123;</span><br><span class="line">        int val5, val6;</span><br><span class="line">        <span class="keyword">while</span>((val6 = rand7()) &gt; <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">while</span>((val5 = rand7()) &gt; <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> (val6 % <span class="number">2</span>) * <span class="number">5</span> + val5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/implement-rand10-using-rand7/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/implem
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>ODD papers reading</title>
    <link href="https://wazxser.github.io/2019/09/18/odd-papers-reading/"/>
    <id>https://wazxser.github.io/2019/09/18/odd-papers-reading/</id>
    <published>2019-09-18T14:19:01.000Z</published>
    <updated>2019-10-09T10:55:10.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>目前大部分论文都是用和原始模型训练集不同的数据集来作为out of distribution的数据集，。<br>OOD——out of distribution<br>ODD——out of distribution detection<br>ID——in distribution<br>ODD也称作： one-class classification, novelty detection, anomaly detection, outlier detection, selective prediction, open set recognition,</p><h1 id="Evaluation-Metrics"><a href="#Evaluation-Metrics" class="headerlink" title="Evaluation Metrics"></a>Evaluation Metrics</h1><ul><li>AUROC（Aera Under Receiver of Characters curve）：受试工作者特征曲线下的面积，ROC曲线的纵坐标是TPR (TP/TP+FN)，横坐标是FPR (FP/FP+TN)</li><li>AUPR （Aera Under the Precision-Recall curve）：precision~recall</li><li>FPR$N$：当有$N\%$的OOD样本被检测出来时，一个ID样本被检测错的概率，越低越好。</li></ul><h2 id="Deep-anomaly-detection-with-outlier-exposure"><a href="#Deep-anomaly-detection-with-outlier-exposure" class="headerlink" title="Deep anomaly detection with outlier exposure"></a><a href="https://arxiv.org/abs/1812.04606v3" target="_blank" rel="noopener">Deep anomaly detection with outlier exposure</a></h2><p>(ICLR’2019) <strong>Dan Hendrycks, Mantas Mazeika, Thomas G. Dietterich</strong></p><ul><li>主要内容：<ul><li>在一些现有的ODD detectors上增加Outlier Exposure机制，设计了一个损失函数，帮助提高OOD检测的准确率<br>$$\mathbb{E} _ {(x, y) \sim \mathcal{D} _ {in}} [ \mathcal{L} (f(x), y) + \lambda \mathbb{E} _ {x^{\prime} \sim \mathcal{D} _ {out}^{OE}} [ \mathcal{L}_{OE} (f(x^{\prime}), f(x), y) ] ]$$</li><li>在baseline方法Maximum Softmax Probability、Confidence Branch和Density estimators增加了关于OOD样本的损失项，使得原有的detectors增强了检测OOD样本的能力。</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/hendrycks/outlier-exposure" target="_blank" rel="noopener">https://github.com/hendrycks/outlier-exposure</a><ul><li>在图片和文本数据集上进行实验 </li></ul></li></ul><h2 id="A-baseline-for-detecting-misclassified-and-out-of-distribution-examples-in-neural-networks"><a href="#A-baseline-for-detecting-misclassified-and-out-of-distribution-examples-in-neural-networks" class="headerlink" title="A baseline for detecting misclassified and out-of-distribution examples in neural networks"></a><a href="https://arxiv.org/abs/1610.02136" target="_blank" rel="noopener">A baseline for detecting misclassified and out-of-distribution examples in neural networks</a></h2><p>(ICLR’17) <strong>Dan Hendrycks, Kevin Gimpel</strong></p><ul><li>主要内容：<ul><li>利用softmax给出的信心值作为判断样本是否是OOD的依据</li><li>高置信度的错误预测经常是来自于softmax的，单从某个样本上看，softmax给的信心值可能是错的，但是从统计上看，错误分类的样本<br>和OOD的样本在softmax给出的信心值上是比正常的正确分类的样本是要低的。</li></ul></li><li>代码实现（Tensorflow）：<a href="https://github.com/hendrycks/error-detection" target="_blank" rel="noopener">https://github.com/hendrycks/error-detection</a></li></ul><h2 id="Training-confidence-calibrated-classifiers-for-detecting-out-of-distribution-samples"><a href="#Training-confidence-calibrated-classifiers-for-detecting-out-of-distribution-samples" class="headerlink" title="Training confidence-calibrated classifiers for detecting out-of-distribution samples"></a><a href="https://arxiv.org/abs/1711.09325" target="_blank" rel="noopener">Training confidence-calibrated classifiers for detecting out-of-distribution samples</a></h2><p>(ICLR’18) <strong>Kimin Lee, Honglak Lee, Kibok Lee, Jinwoo Shin</strong></p><ul><li><p>主要内容：</p><ul><li>在原有模型的训练中，设计了一个新的损失函数（confidence loss）如下，如果样本是OOD的，预测输出的信心值趋近于一个常数值（如，0），如果样本是ID的，则是一般的预测信心值。<br>$$\mathop{min}\limits_{\theta} \ \mathbb{E}_{P_{in} (\hat{x}, \hat{y}) } \ [-logP_{\theta}(y = \hat{y}|\hat{\mathbf{x}}) ] + \beta \mathbb{E}_{P_{out} (\mathbf{x})} \lbrack KL(\mathcal{U}(y) \Vert P_{\theta}(y|\mathbf{x})) \rbrack $$</li><li>训练一个generator网络，用来生成OOD的样本，并且尽可能与ID样本是相近的<br>$$\mathop{min}\limits_{G} \mathop{max}\limits_{D} \ \beta \mathbb{E}_{P_{G(\mathbf{x})}} [ KL (\mathcal(y) || P_{\theta}(y | \mathbf{x})) ] + \mathbb{E}_{P_{in(\mathbf{x})}} [ \mathop{log} D(\mathbf{x}) ] + \mathbb{E}_{P_{G(\mathbf{x})}} [ \mathop{log} (1 - D(\mathbf{x}) ) ]$$</li><li>使用自定义的损失函数，交替训练原始网络和GAN至收敛。</li></ul></li><li><p>代码实现（Pytorch）：<a href="https://github.com/alinlab/Confident_classifier" target="_blank" rel="noopener">https://github.com/alinlab/Confident_classifier</a></p></li></ul><h2 id="Learning-Confidence-for-Out-of-Distribution-Detection-in-Neural-Networks"><a href="#Learning-Confidence-for-Out-of-Distribution-Detection-in-Neural-Networks" class="headerlink" title="Learning Confidence for Out-of-Distribution Detection in Neural Networks"></a><a href="https://arxiv.org/abs/1802.04865" target="_blank" rel="noopener">Learning Confidence for Out-of-Distribution Detection in Neural Networks</a></h2><p>(‘18) <strong>Terrance DeVries, Graham W. Taylor</strong></p><ul><li>主要内容：<ul><li>在网络的penultimate layer之后增加一个用来显示模型对样本分类信心程度大小的一个模块。</li><li>用单层或者多层的全连结神经网络来实现</li><li>设计的损失函数为<br>$$\mathcal{L} = - \sum_{i=1}^{M} log (p_i^{\prime})y_i + - \lambda log (c)$$</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/uoguelph-mlrg/confidence_estimation" target="_blank" rel="noopener">https://github.com/uoguelph-mlrg/confidence_estimation</a></li></ul><h2 id="Enhancing-The-Reliability-of-Out-of-distribution-Image-Detection-in-Neural-Networks"><a href="#Enhancing-The-Reliability-of-Out-of-distribution-Image-Detection-in-Neural-Networks" class="headerlink" title="Enhancing The Reliability of Out-of-distribution Image Detection in Neural Networks"></a><a href="https://arxiv.org/abs/1706.02690" target="_blank" rel="noopener">Enhancing The Reliability of Out-of-distribution Image Detection in Neural Networks</a></h2><p>(ICLR’18) <strong>Shiyu Liang, Yixuan Li, R. Srikant</strong></p><ul><li><p>主要内容：</p><ul><li>在使用的softmax做为ID和OOD样本分类的基础上，增加了temp scaling和在input perturbing的机制。</li><li>Tempperature Scaling:<br>$$S _ {i} (\mathbf{x}; T) = \frac{exp(f_i(\mathbf{x})/ T)}{\sum _ {j = 1} ^ {N} exp (f_j(\mathbf{x})/T)}$$</li><li>Input perturbing:<br>$$\tilde{x} = x - \varepsilon sign (-\nabla _ {x} log S_{\tilde{y}} (\mathbf{x};T)) $$</li></ul></li><li><p>代码实现（Pytorch）：<a href="https://github.com/facebookresearch/odin" target="_blank" rel="noopener">https://github.com/facebookresearch/odin</a></p></li></ul><h2 id="Out-of-Distribution-Detection-using-Multiple-Semantic-Label-Representations"><a href="#Out-of-Distribution-Detection-using-Multiple-Semantic-Label-Representations" class="headerlink" title="Out-of-Distribution Detection using Multiple Semantic Label Representations"></a><a href="https://arxiv.org/abs/1808.06664" target="_blank" rel="noopener">Out-of-Distribution Detection using Multiple Semantic Label Representations</a></h2><p>(NeurIPS’18) <strong>Gabi Shalev, Yossi Adi, Joseph Keshet</strong></p><ul><li>主要内容：<ul><li>在深度神经网络之后接入K个回归函数，输出K个不同词向量</li><li>用词向量之间的$L_2$范数距离做为衡量OOD样本的标准</li></ul></li><li>代码实现： <a href="https://github.com/MLSpeech/semantic_OOD（代码仓库是空的。。。）" target="_blank" rel="noopener">https://github.com/MLSpeech/semantic_OOD（代码仓库是空的。。。）</a></li></ul><h2 id="A-Simple-Unified-Framework-for-Detecting-Out-of-Distribution-Samples-and-Adversarial-Attacks"><a href="#A-Simple-Unified-Framework-for-Detecting-Out-of-Distribution-Samples-and-Adversarial-Attacks" class="headerlink" title="A Simple Unified Framework for Detecting Out-of-Distribution Samples and Adversarial Attacks"></a><a href="https://arxiv.org/abs/1807.03888" target="_blank" rel="noopener">A Simple Unified Framework for Detecting Out-of-Distribution Samples and Adversarial Attacks</a></h2><p>(NeurIPS’18) <strong>Kimin Lee, Kibok Lee, Honglak Lee, Jinwoo Shin</strong></p><ul><li>主要内容：<ul><li>用于OOD样本检测和对抗样本检测</li><li>通过类条件高斯分布来表示每个类别的样本的特征的分布（这个有近似的理论依据），$f(\cdot)$为DNN的penultimate layer的输出。<br>$$P(f(\mathbf{x}) | y = c) = \mathcal{N} (f(\mathbf{x}) | \mu _ {c}, \Sigma)$$</li><li>通过计算待测样本和距离最近的类条件高斯分布之间的马式距离来作为ODD score。</li><li>通过在待测样本上增加扰动（在score增加的方向上）来使得ID样本和OOD样本区别更大</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/pokaxpoka/deep_Mahalanobis_detector" target="_blank" rel="noopener">https://github.com/pokaxpoka/deep_Mahalanobis_detector</a> </li></ul><h2 id="How-to-know-when-machine-learning-does-not-know"><a href="#How-to-know-when-machine-learning-does-not-know" class="headerlink" title="How to know when machine learning does not know"></a><a href="http://www.cleverhans.io/security/2019/05/20/dknn.html" target="_blank" rel="noopener">How to know when machine learning does not know</a></h2><p>(cleverhans blog by Nicolas Papernot and Nicholas Frosst)</p><ul><li>主要内容：<ul><li>提取样本在神经网络中每一层的输出特征</li><li>在每一层的输出中，用k近邻找出与测试样本最相近的k个训练集中的样本</li><li>根据测试样本和找出训练样本的分类结果的差异来判断测试样本是否是OOD的</li></ul></li><li>代码实现：<a href="https://github.com/rodgzilla/machine_learning_deep_knn" target="_blank" rel="noopener">https://github.com/rodgzilla/machine_learning_deep_knn</a></li></ul><h2 id="Deep-One-Class-Classification"><a href="#Deep-One-Class-Classification" class="headerlink" title="Deep One-Class Classification"></a><a href="http://proceedings.mlr.press/v80/ruff18a.html" target="_blank" rel="noopener">Deep One-Class Classification</a></h2><p>(ICML’18) <strong>Lukas Ruff, Robert Vandermeulen, Nico Goernitz, Lucas Deecke, Shoaib Ahmed Siddiqui, Alexander Binder, Emmanuel Müller, Marius Kloft</strong></p><ul><li>主要内容：<ul><li>深度支持向量数据描述。。。将OOD样本的检测问题视为一个二分类问题，这方面研究还有很多工作，One-Class SVM（OC-SVM），编码解码器，GAN之类的。</li><li>目标是学习一个训练集数据的描述，用神经网络表示为一个超球，这个超球尽可能小地只包含ID样本，如果样本落在超球内，是ID样本，如果落在外面是，OOD样本。</li><li></li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/lukasruff/Deep-SVDD" target="_blank" rel="noopener">https://github.com/lukasruff/Deep-SVDD</a><ul><li>做实验时，使用数据集中的一类样本做为ID的，其他类样本为OOD的</li><li>能检测对抗样本</li></ul></li></ul><h2 id="Deep-autoencoding-gaussian-mixture-model-for-unsupervised-anomaly-detection"><a href="#Deep-autoencoding-gaussian-mixture-model-for-unsupervised-anomaly-detection" class="headerlink" title="Deep autoencoding gaussian mixture model for unsupervised anomaly detection"></a><a href="https://openreview.net/forum?id=BJJLHbb0-" target="_blank" rel="noopener">Deep autoencoding gaussian mixture model for unsupervised anomaly detection</a></h2><p>(ICLR’18) <strong>Bo Zong, Qi Song, Martin Renqiang Min, Wei Cheng, Cristian Lumezanu, Daeki Cho, Haifeng Chen</strong></p><ul><li>主要内容：<ul><li>深度自动编码的高斯混合模型，无监督的异常检测问题</li><li>利用深度解码器来对输入进行降维</li><li>利用高斯混合模型通过density estimation来估计每个样本的是否是OOD的分数</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/danieltan07/dagmm" target="_blank" rel="noopener">https://github.com/danieltan07/dagmm</a> （Tensorflow）：<a href="https://github.com/Newcomer520/tf-dagmm" target="_blank" rel="noopener">https://github.com/Newcomer520/tf-dagmm</a><ul><li>OODS datasets：<a href="http://odds.cs.stonybrook.edu/" target="_blank" rel="noopener">http://odds.cs.stonybrook.edu/</a></li></ul></li></ul><h2 id="Anomaly-Detection-with-Generative-Adversarial-Networks"><a href="#Anomaly-Detection-with-Generative-Adversarial-Networks" class="headerlink" title="Anomaly Detection with Generative Adversarial Networks"></a><a href="https://arxiv.org/abs/1703.05921" target="_blank" rel="noopener">Anomaly Detection with Generative Adversarial Networks</a></h2><p>(IPMI’17) <strong>Thomas Schlegl, Philipp Seeböck, Sebastian M. Waldstein, Ursula Schmidt-Erfurth, Georg Langs</strong></p><ul><li>主要内容：<ul><li>通过GAN来学习</li><li>设计一种评价机制来给出样本一个分数做为判断是否是OOD的标准。</li></ul></li><li>代码实现：</li></ul><h2 id="Novelty-Detection-with-GAN"><a href="#Novelty-Detection-with-GAN" class="headerlink" title="Novelty Detection with GAN"></a><a href="https://arxiv.org/abs/1802.10560" target="_blank" rel="noopener">Novelty Detection with GAN</a></h2><p>(‘18) <strong>Mark Kliger, Shachar Fleishman</strong></p><ul><li>主要内容：<ul><li>使用原始训练集和其他分布的数据来训练generator</li><li>使得discriminator能够识别出OOD的样本</li></ul></li><li>代码实现：</li></ul><h2 id="Out-of-distribution-detection-using-an-ensemble-of-self-supervised-leave-out-classifiers"><a href="#Out-of-distribution-detection-using-an-ensemble-of-self-supervised-leave-out-classifiers" class="headerlink" title="Out-of-distribution detection using an ensemble of self supervised leave-out classifiers"></a><a href="https://arxiv.org/abs/1809.03576" target="_blank" rel="noopener">Out-of-distribution detection using an ensemble of self supervised leave-out classifiers</a></h2><p>(ECCV’18) <strong>Apoorv Vyas, Nataraj Jammalamadaka, Xia Zhu, Dipankar Das, Bharat Kaul, Theodore L. Willke</strong></p><ul><li>主要内容：<ul><li>使用集成的方法来判断样本是否是OOD的</li><li>每个分类器都是通过留出法来训练的</li></ul></li><li>代码实现（Pytorch）：<a href="https://github.com/YU1ut/Ensemble-of-Leave-out-Classifiers" target="_blank" rel="noopener">https://github.com/YU1ut/Ensemble-of-Leave-out-Classifiers</a></li></ul><h2 id="Reducing-Network-Agnostophobia"><a href="#Reducing-Network-Agnostophobia" class="headerlink" title="Reducing Network Agnostophobia"></a><a href="https://arxiv.org/abs/1811.04110v2" target="_blank" rel="noopener">Reducing Network Agnostophobia</a></h2><p>(NeurIPS’18) <strong>Akshay Raj Dhamija, Manuel Günther, Terrance E. Boult</strong></p><ul><li>主要内容：<ul><li>Agnostophobia：未知的恐惧</li></ul></li><li>代码实现（Keras）：<a href="https://github.com/Vastlab/Reducing-Network-Agnostophobia" target="_blank" rel="noopener">https://github.com/Vastlab/Reducing-Network-Agnostophobia</a></li></ul><h2 id="Classification-Reconstruction-Learning-for-Open-Set-Recognition"><a href="#Classification-Reconstruction-Learning-for-Open-Set-Recognition" class="headerlink" title="Classification-Reconstruction Learning for Open-Set Recognition"></a><a href="https://arxiv.org/abs/1812.04246?context=cs" target="_blank" rel="noopener">Classification-Reconstruction Learning for Open-Set Recognition</a></h2><p>(‘18) <strong>Ryota Yoshihashi, Wen Shao, Rei Kawakami, Shaodi You, Makoto Iida, Takeshi Naemura</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现：</li></ul><h2 id="On-the-Foundations-of-Noise-free-Selective-Classification"><a href="#On-the-Foundations-of-Noise-free-Selective-Classification" class="headerlink" title="On the Foundations of Noise-free Selective Classification"></a><a href="http://jmlr.org/papers/volume11/el-yaniv10a/el-yaniv10a.pdf" target="_blank" rel="noopener">On the Foundations of Noise-free Selective Classification</a></h2><p><strong>El-Yaniv, Ran，YairWiener</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现：</li></ul><h2 id="Selective-Classification-for-Deep-Neural-Networks"><a href="#Selective-Classification-for-Deep-Neural-Networks" class="headerlink" title="Selective Classification for Deep Neural Networks"></a><a href="http://papers.nips.cc/paper/7073-selective-classification-for-deep-neural-networks" target="_blank" rel="noopener">Selective Classification for Deep Neural Networks</a></h2><p>(NeurIPS’17) <strong>Yonatan Geifman, Ran El-Yaniv</strong></p><ul><li>主要内容：<ul><li>在原始网络的基础上再训练一个selective classifier</li><li>允许用户设置期望的风险水平</li><li></li></ul></li><li>代码实现：</li></ul><h2 id="To-Trust-Or-Not-To-Trust-A-Classifier"><a href="#To-Trust-Or-Not-To-Trust-A-Classifier" class="headerlink" title="To Trust Or Not To Trust A Classifier"></a><a href="https://arxiv.org/abs/1805.11783v2" target="_blank" rel="noopener">To Trust Or Not To Trust A Classifier</a></h2><p>(NeurIPS’18) <strong>Heinrich Jiang, Been Kim, Melody Y. Guan, Maya Gupta</strong></p><ul><li>主要内容：<ul><li>设计一种评分标准，分数高则认为分类器结果哦可信任，低则不可信任</li><li>分数为，测试样本到除了预测分类以外，其他分类中距离最近样本的距离和测试样本到预测分类样本的距离</li></ul></li><li>代码实现： <a href="https://github.com/google/TrustScore" target="_blank" rel="noopener">https://github.com/google/TrustScore</a></li></ul><h2 id="Simple-and-Scalable-Predictive-Uncertainty-Estimation-using-Deep-Ensembles"><a href="#Simple-and-Scalable-Predictive-Uncertainty-Estimation-using-Deep-Ensembles" class="headerlink" title="Simple and Scalable Predictive Uncertainty Estimation using Deep Ensembles"></a><a href="https://arxiv.org/abs/1612.01474" target="_blank" rel="noopener">Simple and Scalable Predictive Uncertainty Estimation using Deep Ensembles</a></h2><p>(NeurIPS’17) <strong>Balaji Lakshminarayanan, Alexander Pritzel, Charles Blundell</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（Tensorflow）：<a href="https://github.com/vvanirudh/deep-ensembles-uncertainty" target="_blank" rel="noopener">https://github.com/vvanirudh/deep-ensembles-uncertainty</a></li></ul><h2 id="Open-Category-Detection-with-PAC-Guarantees"><a href="#Open-Category-Detection-with-PAC-Guarantees" class="headerlink" title="Open Category Detection with PAC Guarantees"></a><a href="https://arxiv.org/abs/1808.00529" target="_blank" rel="noopener">Open Category Detection with PAC Guarantees</a></h2><p>(ICML’18) <strong>Si Liu, Risheek Garrepalli, Thomas G. Dietterich, Alan Fern, Dan Hendrycks</strong></p><ul><li>代码实现（R）：<a href="https://github.com/liusi2019/ocd" target="_blank" rel="noopener">https://github.com/liusi2019/ocd</a></li></ul><h2 id="Metric-Learning-for-Novelty-and-Anomaly-Detection"><a href="#Metric-Learning-for-Novelty-and-Anomaly-Detection" class="headerlink" title="Metric Learning for Novelty and Anomaly Detection"></a><a href="https://arxiv.org/abs/1808.05492" target="_blank" rel="noopener">Metric Learning for Novelty and Anomaly Detection</a></h2><p>(BMVC’18) <strong>Marc Masana, Idoia Ruiz, Joan Serrat, Joost van de Weijer, Antonio M. Lopez</strong></p><ul><li>代码实现（Tensorflow）：<a href="https://mmasana.github.io/OoD_Mining/" target="_blank" rel="noopener">https://mmasana.github.io/OoD_Mining/</a></li></ul><h2 id="WAIC-but-Why-Generative-Ensembles-for-Robust-Anomaly-Detection"><a href="#WAIC-but-Why-Generative-Ensembles-for-Robust-Anomaly-Detection" class="headerlink" title="WAIC, but Why? Generative Ensembles for Robust Anomaly Detection"></a><a href="https://arxiv.org/abs/1810.01392" target="_blank" rel="noopener">WAIC, but Why? Generative Ensembles for Robust Anomaly Detection</a></h2><p>(‘18) <strong>Hyunsun Choi, Eric Jang, Alexander A. Alemi</strong></p><ul><li>主要内容：<ul><li>WAIC：估计训练集和测试集数据期望之间的差距</li></ul></li><li>代码实现： </li></ul><h2 id="Towards-open-world-recognition"><a href="#Towards-open-world-recognition" class="headerlink" title="Towards open world recognition"></a><a href="https://arxiv.org/abs/1412.5687" target="_blank" rel="noopener">Towards open world recognition</a></h2><p>(CVPR’15) <strong>Abhijit Bendale, Terrance Boult</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（MATLAB）：<a href="https://github.com/abhijitbendale/OWR" target="_blank" rel="noopener">https://github.com/abhijitbendale/OWR</a></li></ul><h2 id="Anomaly-Detection-using-One-Class-Neural-Networks"><a href="#Anomaly-Detection-using-One-Class-Neural-Networks" class="headerlink" title="Anomaly Detection using One-Class Neural Networks"></a><a href="https://arxiv.org/abs/1802.06360" target="_blank" rel="noopener">Anomaly Detection using One-Class Neural Networks</a></h2><p>(‘18) <strong>Raghavendra Chalapathy, Aditya Krishna Menon, Sanjay Chawla</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（）：</li></ul><h2 id="Figure-of-Merit-Training-for-Detection-and-Spotting"><a href="#Figure-of-Merit-Training-for-Detection-and-Spotting" class="headerlink" title="Figure of Merit Training for Detection and Spotting"></a><a href="http://papers.nips.cc/paper/792-figure-of-merit-training-for-detection-and-spotting" target="_blank" rel="noopener">Figure of Merit Training for Detection and Spotting</a></h2><p>(NeurIPS’93) <strong>Eric I. Chang and Richard P. Lippmann</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现：</li></ul><h2 id="Towards-Open-Set-Deep-Networks"><a href="#Towards-Open-Set-Deep-Networks" class="headerlink" title="Towards Open Set Deep Networks"></a><a href="https://arxiv.org/abs/1511.06233" target="_blank" rel="noopener">Towards Open Set Deep Networks</a></h2><p>(CVPR’16) <strong>Abhijit Bendale, Terrance Boult</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（caffe）： <a href="https://github.com/abhijitbendale/OSDN" target="_blank" rel="noopener">https://github.com/abhijitbendale/OSDN</a>  （keras）<a href="https://github.com/aadeshnpn/OSDN" target="_blank" rel="noopener">https://github.com/aadeshnpn/OSDN</a></li></ul><h2 id="A-loss-framework-for-calibrated-anomaly-detection"><a href="#A-loss-framework-for-calibrated-anomaly-detection" class="headerlink" title="A loss framework for calibrated anomaly detection"></a><a href="http://papers.nips.cc/paper/7422-a-loss-framework-for-calibrated-anomaly-detection" target="_blank" rel="noopener">A loss framework for calibrated anomaly detection</a></h2><p>(NeurIPS’18) <strong>Aditya Krishna Menon, Robert C. Williamson</strong></p><ul><li>主要内容：<br>  - </li><li>代码实现（）：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;&lt;p&gt;目前大部分论文都是用和原始模型训练集不同的数据集来作为out of distribution的数据集
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode_137_Single_Number_II</title>
    <link href="https://wazxser.github.io/2019/04/29/leetcode-137-Single-Number-II/"/>
    <id>https://wazxser.github.io/2019/04/29/leetcode-137-Single-Number-II/</id>
    <published>2019-04-29T13:56:38.000Z</published>
    <updated>2019-04-29T14:08:41.798Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/</a></p><p>感觉这道题好有意思。题目大意为：给一个数组，数组中除了一个数字出现一次外，其他数字均出现<br>三次，找出这个出现一次的数字。</p><p>思路：从网上看的题解，利用位运算，记录整数的二进制表示中每一位1出现的次数。</p><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            ones = (nums[i] ^ ones) &amp; ~twos;</span><br><span class="line">            twos = (nums[i] ^ twos) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/single-number-ii/&lt;
      
    
    </summary>
    
      <category term="Online Judge" scheme="https://wazxser.github.io/categories/Online-Judge/"/>
    
    
      <category term="leetcode" scheme="https://wazxser.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统修复</title>
    <link href="https://wazxser.github.io/2019/04/19/Ubuntu%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8D/"/>
    <id>https://wazxser.github.io/2019/04/19/Ubuntu系统修复/</id>
    <published>2019-04-19T06:52:53.000Z</published>
    <updated>2019-04-19T07:48:18.513Z</updated>
    
    <content type="html"><![CDATA[<p>早上在毫无心理准备和几个月没备份的情况下，Ubuntu进不去了，内心十分崩溃。</p><p>交代环境：Ubuntu16.04+Windows10双系统，NVIDIA 1080Ti显卡。</p><p>具体表现为，开机出现Grub引导界面，进入Ubuntu只有长时间黑屏，Ctrl+Alt+F1进入命令行<br>也没有任何反应。可以进入Windows系统。</p><h1 id="修复步骤"><a href="#修复步骤" class="headerlink" title="修复步骤"></a>修复步骤</h1><ul><li>从Grub引导界面进入Ubuntu高级选项，选择recovery mode进入，会有一大堆的log不断<br>输出，最后停止时会看到/dev/sdb4文件系统有错误，requires a manual fsck</li><li>但是我在之后recovery mode的命令行模式没有办法修复（我只尝试输入了fsck命令，<br>没有指定/dev/sdb4，也许会有差别），这里不太确定。</li><li>从Ubuntu启动盘进入Try Ubuntu without install，这里可以看到之前Ubuntu系统<br>中的文件，如果系统不能修复，应该可以从这里把文件和代码抢救回来了。</li><li>打开命令行，输入<code>sudo fsck -f /dev/sdb4</code>，我这里一定要加/dev/sdb4，否则没效果。<br>执行完如果还有错误，重复执行上述命令直到没有错误为止。</li><li>重启电脑，从Grub正常进入Ubuntu，发现修复成功了，恢复正常了。</li></ul><h1 id="曲折之路"><a href="#曲折之路" class="headerlink" title="曲折之路"></a>曲折之路</h1><ul><li>综合大部分CSDN的说法，应该是内核在你不知觉的时候升级了，而新的内核没有NVIDIA显卡<br>驱动，所以会黑屏，尝试编辑Ubuntu内核命令行参数（在Grub界面上按<code>e</code>进入编辑），<br>（ro改为rw，加上nomodeset等参数），因为的确发现Ubuntu高级选项中有好几个内核的版本，<br>以为就是这个错误，但其实没有，应该我的内核和显卡驱动都是可以加载好的吧。</li><li>不明白为什么会有多个内核版本</li><li>不明白为什么我的电脑在跑稍大一点训练任务的时候就会重启，就是重启导致文件系统错误，<br>才会今天开不了机。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>平时习惯照搬网上经验，还是要经过脑子思考才可以。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早上在毫无心理准备和几个月没备份的情况下，Ubuntu进不去了，内心十分崩溃。&lt;/p&gt;
&lt;p&gt;交代环境：Ubuntu16.04+Windows10双系统，NVIDIA 1080Ti显卡。&lt;/p&gt;
&lt;p&gt;具体表现为，开机出现Grub引导界面，进入Ubuntu只有长时间黑屏，C
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://wazxser.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>神经网络对抗样本和测试方向论文总结</title>
    <link href="https://wazxser.github.io/2019/03/04/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC%E5%92%8C%E6%B5%8B%E8%AF%95%E6%96%B9%E5%90%91%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>https://wazxser.github.io/2019/03/04/神经网络对抗样本和测试方向论文总结/</id>
    <published>2019-03-04T08:06:36.000Z</published>
    <updated>2019-04-21T13:29:38.264Z</updated>
    
    <content type="html"><![CDATA[<p>把论文分为攻击、防御、测试、验证、其他几类。<br>攻击指通过一定的方法设计，生成能够欺骗神经网络的对抗样本。<br>防御指使神经网络能够抵抗对抗样本的攻击。<br>测试感觉是软工领域的说法，一般目的是希望生成能够探测到更多神经网络错误的更完备的测试集。<br>验证是从理论上分析神经网络的安全性，是最困难的领域。</p><h1 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h1><h2 id="1-Intriguing-properties-of-neural-networks"><a href="#1-Intriguing-properties-of-neural-networks" class="headerlink" title="1.Intriguing properties of neural networks"></a>1.<a href="https://arxiv.org/pdf/1312.6199.pdf" target="_blank" rel="noopener">Intriguing properties of neural networks</a></h2><p>2014年的论文，第一次提出了对抗样本。即在原始图像中添加了人眼不易发觉的扰动，会造成神经网络分类错误，这是一种非常反直觉的现象，也揭示了神经网络在安全领域中的应用会存在很大的隐患。同时，本文提出了一种生成对抗样本的方法。</p><p>首先将生成对抗样本形式化为一个约束优化问题：</p><p>\(Minimize \left \| r \right \|_2 subject to:\)<br>\(1. f(x+r) = l\)<br>\(2. x+r \in [0, 1]^m\)</p><p>\( Minimize c|r| + loss_{f}(x+r, l) subject to x+r \in [0, 1]^m\)<br>通过L-BFGS算法来进行求解。<br>这篇论文中还提出了一种观点，神经网络的语义信息是存在于网络中高层单元空间中的，而不是在单独的个体中。因为通过实验发现单独的高层单元个体和随机线性组合的高层单元是没有什么区别的。同时，这篇论文也提出了对抗样本存在移植性，对抗训练等观点。</p><h2 id="2-Explaining-and-Harnessing-Adversarial-Examples"><a href="#2-Explaining-and-Harnessing-Adversarial-Examples" class="headerlink" title="2.Explaining and Harnessing Adversarial Examples"></a>2.<a href="https://arxiv.org/abs/1412.6572" target="_blank" rel="noopener">Explaining and Harnessing Adversarial Examples</a></h2><p>这篇论文中提出了FGSM算法，即Fast Gradient Sign Method，可以更加快速地生成对抗样本。<br>生成扰动的具体公式为：<br>$$\mathbf{\eta} = \epsilon sign(\nabla_{x}J(\mathbf{\theta} , \mathbf{x}, y))$$<br>这里，$J$是神经网络的损失函数，$y$是输入样本的label，$\eta$是常数调节步长，$\theta$是神经网络模型的参数。</p><p>同时，这篇论文也提出了神经网络在对抗样本方面展现的脆弱性主要是因为神经网络的线性性和对抗训练的方法。<br>这篇论文的FGSM是one step的，后续也提出了迭代的FGSM，可以用来求更近距离的对抗样本。</p><h2 id="3-The-Limitations-of-Deep-Learning-in-Adversarial-Settings"><a href="#3-The-Limitations-of-Deep-Learning-in-Adversarial-Settings" class="headerlink" title="3.The Limitations of Deep Learning in Adversarial Settings"></a>3.<a href="https://arxiv.org/abs/1511.07528" target="_blank" rel="noopener">The Limitations of Deep Learning in Adversarial Settings</a></h2><p>这篇论文的提出的攻击方法是JSMA，即Jacobian Saliency Map Attack。<br>首先解释什么是Jacobian Matrix：<br>神经网络输出的每一维对输出的每一维求导。<br><img src="Jacobian Matrix.png" alt=""><br>然后根据得到的Jacobian Matrix构造对抗显著图（Adversarial Saliency Maps）：<br><img src="构造显著图.png" alt=""></p><h2 id="4-Towards-Evaluating-the-Robustness-of-Neural-Networks"><a href="#4-Towards-Evaluating-the-Robustness-of-Neural-Networks" class="headerlink" title="4.Towards Evaluating the Robustness of Neural Networks"></a>4.<a href="https://arxiv.org/abs/1608.04644" target="_blank" rel="noopener">Towards Evaluating the Robustness of Neural Networks</a></h2><p>CW攻击方法，因为对抗样本求解问题的难度问题，探索尝试新的目标函数和优化方法，并且给出了基于三种范数的攻击。</p><h2 id="5-DeepFool-a-simple-and-accurate-method-to-fool-deep-neural-networks"><a href="#5-DeepFool-a-simple-and-accurate-method-to-fool-deep-neural-networks" class="headerlink" title="5.DeepFool: a simple and accurate method to fool deep neural networks"></a>5.<a href="https://arxiv.org/abs/1511.04599" target="_blank" rel="noopener">DeepFool: a simple and accurate method to fool deep neural networks</a></h2><p>利用直线距离最短的思想，设计优化方法。</p><h2 id="6-Practical-Black-Box-Attacks-against-Machine-Learning"><a href="#6-Practical-Black-Box-Attacks-against-Machine-Learning" class="headerlink" title="6.Practical Black-Box Attacks against Machine Learning"></a>6.<a href="https://arxiv.org/abs/1602.02697" target="_blank" rel="noopener">Practical Black-Box Attacks against Machine Learning</a></h2><p>黑盒攻击</p><h2 id="7-Universal-adversarial-perturbations"><a href="#7-Universal-adversarial-perturbations" class="headerlink" title="7.Universal adversarial perturbations"></a>7.<a href="https://arxiv.org/abs/1610.08401" target="_blank" rel="noopener">Universal adversarial perturbations</a></h2><h2 id="8-One-pixel-attack-for-fooling-deep-neural-networks"><a href="#8-One-pixel-attack-for-fooling-deep-neural-networks" class="headerlink" title="8.One pixel attack for fooling deep neural networks"></a>8.<a href="https://arxiv.org/abs/1710.08864" target="_blank" rel="noopener">One pixel attack for fooling deep neural networks</a></h2><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><h2 id="1-Distillation-as-a-Defense-to-Adversarial-Perturbations-against-Deep-Neural-Networks"><a href="#1-Distillation-as-a-Defense-to-Adversarial-Perturbations-against-Deep-Neural-Networks" class="headerlink" title="1.Distillation as a Defense to Adversarial Perturbations against Deep Neural Networks"></a>1.<a href="https://arxiv.org/abs/1511.04508" target="_blank" rel="noopener">Distillation as a Defense to Adversarial Perturbations against Deep Neural Networks</a></h2><h2 id="2-Adversarial-Sample-Detection-for-Deep-Neural-Network-through-Model-Mutation-Testing"><a href="#2-Adversarial-Sample-Detection-for-Deep-Neural-Network-through-Model-Mutation-Testing" class="headerlink" title="2.Adversarial Sample Detection for Deep Neural Network through Model Mutation Testing"></a>2.<a href="https://arxiv.org/abs/1812.05793" target="_blank" rel="noopener">Adversarial Sample Detection for Deep Neural Network through Model Mutation Testing</a></h2><p>ICSE’19</p><h2 id="3-Ensemble-Adversarial-Training-Attacks-and-Defenses"><a href="#3-Ensemble-Adversarial-Training-Attacks-and-Defenses" class="headerlink" title="3.Ensemble Adversarial Training: Attacks and Defenses"></a>3.<a href="https://arxiv.org/abs/1705.07204" target="_blank" rel="noopener">Ensemble Adversarial Training: Attacks and Defenses</a></h2><p>ICLR’18<br>Florian Tramèr, Alexey Kurakin, Nicolas Papernot, Ian Goodfellow, Dan Boneh, Patrick McDaniel</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="1-DeepXplore-Automated-Whitebox-Testing-of-Deep-Learning-Systems"><a href="#1-DeepXplore-Automated-Whitebox-Testing-of-Deep-Learning-Systems" class="headerlink" title="1.DeepXplore: Automated Whitebox Testing of Deep Learning Systems"></a>1.<a href="https://arxiv.org/abs/1705.06640" target="_blank" rel="noopener">DeepXplore: Automated Whitebox Testing of Deep Learning Systems</a></h2><p>SOSP’17 Best Paper</p><h2 id="2-DeepTest-Automated-Testing-of-Deep-Neural-Network-driven-Autonomous-Cars"><a href="#2-DeepTest-Automated-Testing-of-Deep-Neural-Network-driven-Autonomous-Cars" class="headerlink" title="2.DeepTest: Automated Testing of Deep-Neural-Network-driven Autonomous Cars"></a>2.<a href="https://arxiv.org/abs/1708.08559" target="_blank" rel="noopener">DeepTest: Automated Testing of Deep-Neural-Network-driven Autonomous Cars</a></h2><p>ICSE’18</p><h2 id="3-DeepGauge-Multi-Granularity-Testing-Criteria-for-Deep-Learning-Systems"><a href="#3-DeepGauge-Multi-Granularity-Testing-Criteria-for-Deep-Learning-Systems" class="headerlink" title="3.DeepGauge: Multi-Granularity Testing Criteria for Deep Learning Systems"></a>3.<a href="https://arxiv.org/abs/1803.07519" target="_blank" rel="noopener">DeepGauge: Multi-Granularity Testing Criteria for Deep Learning Systems</a></h2><p>ASE’18 Distinguished Paper</p><h2 id="4-MODE-automated-neural-network-model-debugging-via-state-differential-analysis-and-input-selection"><a href="#4-MODE-automated-neural-network-model-debugging-via-state-differential-analysis-and-input-selection" class="headerlink" title="4.MODE: automated neural network model debugging via state differential analysis and input selection"></a>4.<a href="https://dl.acm.org/citation.cfm?id=3236082" target="_blank" rel="noopener">MODE: automated neural network model debugging via state differential analysis and input selection</a></h2><p>FSE’18</p><h2 id="5-Testing-Deep-Neural-Networks"><a href="#5-Testing-Deep-Neural-Networks" class="headerlink" title="5.Testing Deep Neural Networks"></a>5.<a href="https://arxiv.org/abs/1803.04792" target="_blank" rel="noopener">Testing Deep Neural Networks</a></h2><h2 id="6-DeepMutation-Mutation-Testing-of-Deep-Learning-Systems"><a href="#6-DeepMutation-Mutation-Testing-of-Deep-Learning-Systems" class="headerlink" title="6.DeepMutation: Mutation Testing of Deep Learning Systems"></a>6.<a href="https://arxiv.org/abs/1805.05206" target="_blank" rel="noopener">DeepMutation: Mutation Testing of Deep Learning Systems</a></h2><h2 id="7-Combinatorial-Testing-for-Deep-Learning-Systems"><a href="#7-Combinatorial-Testing-for-Deep-Learning-Systems" class="headerlink" title="7.Combinatorial Testing for Deep Learning Systems"></a>7.<a href="https://arxiv.org/abs/1806.07723" target="_blank" rel="noopener">Combinatorial Testing for Deep Learning Systems</a></h2><h2 id="8-DeepRoad-GAN-Based-Metamorphic-Testing-and-Input-Validation-Framework-for-Autonomous-Driving-Systems"><a href="#8-DeepRoad-GAN-Based-Metamorphic-Testing-and-Input-Validation-Framework-for-Autonomous-Driving-Systems" class="headerlink" title="8.DeepRoad: GAN-Based Metamorphic Testing and Input Validation Framework for Autonomous Driving Systems"></a>8.<a href="https://dl.acm.org/citation.cfm?id=3238187" target="_blank" rel="noopener">DeepRoad: GAN-Based Metamorphic Testing and Input Validation Framework for Autonomous Driving Systems</a></h2><p>ASE’18</p><h2 id="9-Guiding-Deep-Learning-System-Testing-using-Surprise-Adequacy"><a href="#9-Guiding-Deep-Learning-System-Testing-using-Surprise-Adequacy" class="headerlink" title="9.Guiding Deep Learning System Testing using Surprise Adequacy"></a>9.<a href="https://arxiv.org/abs/1808.08444" target="_blank" rel="noopener">Guiding Deep Learning System Testing using Surprise Adequacy</a></h2><p>ICSE’19</p><h2 id="10-TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing"><a href="#10-TensorFuzz-Debugging-Neural-Networks-with-Coverage-Guided-Fuzzing" class="headerlink" title="10.TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing"></a>10.<a href="https://arxiv.org/abs/1807.10875" target="_blank" rel="noopener">TensorFuzz: Debugging Neural Networks with Coverage-Guided Fuzzing</a></h2><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><h2 id="1-Safety-Verification-of-Deep-Neural-Networks"><a href="#1-Safety-Verification-of-Deep-Neural-Networks" class="headerlink" title="1.Safety Verification of Deep Neural Networks"></a>1.<a href="https://arxiv.org/abs/1610.06940" target="_blank" rel="noopener">Safety Verification of Deep Neural Networks</a></h2><p>Invited paper at CAV’17<br>Xiaowei Huang, Marta Kwiatkowska, Sen Wang, Min Wu</p><h2 id="2-Reluplex-An-Efficient-SMT-Solver-for-Verifying-Deep-Neural-Networks"><a href="#2-Reluplex-An-Efficient-SMT-Solver-for-Verifying-Deep-Neural-Networks" class="headerlink" title="2.Reluplex: An Efficient SMT Solver for Verifying Deep Neural Networks"></a>2.<a href="https://arxiv.org/abs/1702.01135" target="_blank" rel="noopener">Reluplex: An Efficient SMT Solver for Verifying Deep Neural Networks</a></h2><p>Extended version of a paper with the same title that appeared at CAV 2017<br>Guy Katz, Clark Barrett, David Dill, Kyle Julian, Mykel Kochenderfer</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-Measuring-Neural-Net-Robustness-with-Constraints"><a href="#1-Measuring-Neural-Net-Robustness-with-Constraints" class="headerlink" title="1.Measuring Neural Net Robustness with Constraints"></a>1.<a href="https://arxiv.org/abs/1605.07262" target="_blank" rel="noopener">Measuring Neural Net Robustness with Constraints</a></h2><p>NIPS’16</p><h2 id="2-Evaluating-the-Robustness-of-Neural-Networks-An-Extreme-Value-Theory-Approach"><a href="#2-Evaluating-the-Robustness-of-Neural-Networks-An-Extreme-Value-Theory-Approach" class="headerlink" title="2.Evaluating the Robustness of Neural Networks: An Extreme Value Theory Approach"></a>2.<a href="https://arxiv.org/abs/1801.10578" target="_blank" rel="noopener">Evaluating the Robustness of Neural Networks: An Extreme Value Theory Approach</a></h2><p>ICLR’18</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;把论文分为攻击、防御、测试、验证、其他几类。&lt;br&gt;攻击指通过一定的方法设计，生成能够欺骗神经网络的对抗样本。&lt;br&gt;防御指使神经网络能够抵抗对抗样本的攻击。&lt;br&gt;测试感觉是软工领域的说法，一般目的是希望生成能够探测到更多神经网络错误的更完备的测试集。&lt;br&gt;验证是从理论
      
    
    </summary>
    
      <category term="论文阅读" scheme="https://wazxser.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="神经网络" scheme="https://wazxser.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="对抗样本" scheme="https://wazxser.github.io/tags/%E5%AF%B9%E6%8A%97%E6%A0%B7%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加搜索功能</title>
    <link href="https://wazxser.github.io/2018/08/16/Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
    <id>https://wazxser.github.io/2018/08/16/Hexo博客添加搜索功能/</id>
    <published>2018-08-16T12:13:10.000Z</published>
    <updated>2018-08-16T20:28:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>为自己的博客添加搜索功能。</p><h1 id="local-search"><a href="#local-search" class="headerlink" title="local_search"></a>local_search</h1><ul><li><p>安装hexo-generator-searchdb模块，在博客的根目录下执行以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>在站点配置文件中加入如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p>在主题配置文件中开启local_search功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li></ul><h1 id="algolia-search"><a href="#algolia-search" class="headerlink" title="algolia_search"></a>algolia_search</h1><p><a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">官方教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为自己的博客添加搜索功能。&lt;/p&gt;
&lt;h1 id=&quot;local-search&quot;&gt;&lt;a href=&quot;#local-search&quot; class=&quot;headerlink&quot; title=&quot;local_search&quot;&gt;&lt;/a&gt;local_search&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="博客" scheme="https://wazxser.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://wazxser.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>POJ1321棋盘问题</title>
    <link href="https://wazxser.github.io/2018/08/15/POJ1321%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/"/>
    <id>https://wazxser.github.io/2018/08/15/POJ1321棋盘问题/</id>
    <published>2018-08-15T07:22:17.000Z</published>
    <updated>2018-08-15T15:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://vjudge.net/article/187" target="_blank" rel="noopener">kuangbin带你飞专题</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://vjudge.net/problem/POJ-1321" target="_blank" rel="noopener">POJ1321</a><br>在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入含有多组测试数据。<br>每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n<br>当为-1 -1时表示输入结束。<br>随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>深搜，回溯</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;memory.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> pan[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pan[i][j] == <span class="string">'#'</span> &amp;&amp; !row[i] &amp;&amp; !col[j])&#123;</span><br><span class="line">                row[i] = <span class="number">1</span>;</span><br><span class="line">                col[j] = <span class="number">1</span>;</span><br><span class="line">                dfs(sum+<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">                row[i] = <span class="number">0</span>;</span><br><span class="line">                col[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k) &amp;&amp; n != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//memset(row, 0, sizeof(row));</span></span><br><span class="line">        <span class="comment">//memset(col, 0, sizeof(col));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            row[i] = col[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;pan[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://vjudge.net/article/187&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kuangbin带你飞专题&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="kuangbin带你飞 专题一 简单搜索" scheme="https://wazxser.github.io/categories/kuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E-%E4%B8%93%E9%A2%98%E4%B8%80-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="acm" scheme="https://wazxser.github.io/tags/acm/"/>
    
      <category term="dfs回溯" scheme="https://wazxser.github.io/tags/dfs%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>POJ2251DungeonMaster</title>
    <link href="https://wazxser.github.io/2018/08/15/POJ2251DungeonMaster/"/>
    <id>https://wazxser.github.io/2018/08/15/POJ2251DungeonMaster/</id>
    <published>2018-08-15T07:22:17.000Z</published>
    <updated>2018-08-17T22:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://vjudge.net/article/187" target="_blank" rel="noopener">kuangbin带你飞专题</a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://vjudge.net/problem/POJ-2251" target="_blank" rel="noopener">POJ1321</a><br>You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.</p><p>Is an escape possible? If yes, how long will it take?</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).<br>L is the number of levels making up the dungeon.<br>R and C are the number of rows and columns making up the plan of each level.<br>Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Each maze generates one line of output. If it is possible to reach the exit, print a line of the form<br>Escaped in x minute(s).</p><p>where x is replaced by the shortest time it takes to escape.<br>If it is not possible to escape, print the line<br>Trapped!</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">S....</span><br><span class="line">.###.</span><br><span class="line">.##..</span><br><span class="line">###.#</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">##.##</span><br><span class="line">##...</span><br><span class="line"></span><br><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#.###</span><br><span class="line">####E</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">S##</span><br><span class="line">#E#</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Escaped in <span class="number">11</span> minute(s).</span><br><span class="line">Trapped!</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题意大致是一个三层迷宫，从出发点S到终点E，求最少时间，考虑广搜求解最优解问题，使用队列保存每步的坐标，每次移动有6种情况可以用一个二维数组来表示，设一个visit数组来表示到每个位置的最少时间，每次都是以能够到达该位置的前一个位置的最少时间+1来更新。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;memory.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> pan[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> row[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pan[i][j] == <span class="string">'#'</span> &amp;&amp; !row[i] &amp;&amp; !col[j])&#123;</span><br><span class="line">                row[i] = <span class="number">1</span>;</span><br><span class="line">                col[j] = <span class="number">1</span>;</span><br><span class="line">                dfs(sum+<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">                row[i] = <span class="number">0</span>;</span><br><span class="line">                col[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k) &amp;&amp; n != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//memset(row, 0, sizeof(row));</span></span><br><span class="line">        <span class="comment">//memset(col, 0, sizeof(col));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            row[i] = col[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c"</span>, &amp;pan[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://vjudge.net/article/187&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kuangbin带你飞专题&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="kuangbin带你飞 专题一 简单搜索" scheme="https://wazxser.github.io/categories/kuangbin%E5%B8%A6%E4%BD%A0%E9%A3%9E-%E4%B8%93%E9%A2%98%E4%B8%80-%E7%AE%80%E5%8D%95%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="acm" scheme="https://wazxser.github.io/tags/acm/"/>
    
      <category term="bfs" scheme="https://wazxser.github.io/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>神经网络的激活函数</title>
    <link href="https://wazxser.github.io/2018/08/14/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-1/"/>
    <id>https://wazxser.github.io/2018/08/14/神经网络的激活函数-1/</id>
    <published>2018-08-14T03:05:41.000Z</published>
    <updated>2018-08-14T15:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>激活函数给神经网络引入了非线性因素，大大增加了神经网络的可解释性难度。常用激活函数大致经历了sigmoid到tanh到ReLU的演变过程。</p><h1 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>$$\sigma (x) = \frac{1}{1+e^{-x}}$$<br><img src="85858640-5.png" alt=""></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>函数饱和导致梯度消失问题，当神经元的激活值在0和1附近时，梯度接近为0，会饱和，导致梯度消失，几乎没有信号通过神经网络传回上一层。<br>函数输出不是以0为中心，导致梯度下降权重更新时出现z字型下降。</p><h1 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h1><p>双曲正切函数</p><h2 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h2><p>$$\sigma (x) = \frac{e^x - e^{-x}}{e^x+e^{-x}}$$<br><img src="43148640-7.png" alt=""></p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>解决了sigmoid函数输出不以0为中心的问题，仍然存在饱和问题。</p><h1 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h1><p>Rectified Linear Unit(ReLU)，目前最常用的激活函数。</p><h2 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h2><p>$$\sigma (x) = max(x, 0)$$<br>当输入x&gt;0时，输出为x，当输入x&lt;0时，输出为0。<br><img src="06134640-9.png" alt=""></p><h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p>计算简单，效率高，不会饱和，对随机梯度下降的收敛有巨大的加速作用。由于其稀疏激活性，ReLU神经元很容易die并且不可逆，导致数据多样化的丢失，模型无法学习到有效特征。</p><h1 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h1><h2 id="公式-3"><a href="#公式-3" class="headerlink" title="公式"></a>公式</h2><p>$$\sigma (x) = max(\varepsilon x, x)$$<br>$\varepsilon$是一个比较小的负数梯度值，例如0.01。<br><img src="12034640-11.png" alt=""></p><h2 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h2><p>使负轴信息不会全部丢失，解决了ReLU中神经元die掉的问题。</p><h1 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h1><p>将神经网络的输出转换为可能性大小，用在最后一层输出层，输出值在[0,1]范围内，同时各输出值相加和为1，满足输出值代表的可能性的概率分布。</p><h2 id="公式-4"><a href="#公式-4" class="headerlink" title="公式"></a>公式</h2><p>$${\sigma (\mathbf{z})}_{j} = \frac{e^{z_j}}{\sum_{k=1}^{K}{e^{z_k}}},\mathrm{for}j=1,…,K$$<br><img src="v2-68a7dfdf613d8cd43f0569184b206c5c_hd.jpg" alt=""></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/32610035" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32610035</a><br><a href="https://feisky.xyz/machine-learning/neural-networks/active.html" target="_blank" rel="noopener">https://feisky.xyz/machine-learning/neural-networks/active.html</a><br><a href="https://www.jiqizhixin.com/articles/2017-11-02-26" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2017-11-02-26</a><br><a href="https://zh.wikipedia.org/wiki/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0</a><br><a href="https://www.jianshu.com/p/22d9720dbf1a" target="_blank" rel="noopener">https://www.jianshu.com/p/22d9720dbf1a</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;激活函数给神经网络引入了非线性因素，大大增加了神经网络的可解释性难度。常用激活函数大致经历了sigmoid到tanh到ReLU的演变过程。&lt;/p&gt;
&lt;h1 id=&quot;sigmoid&quot;&gt;&lt;a href=&quot;#sigmoid&quot; class=&quot;headerlink&quot; title=&quot;s
      
    
    </summary>
    
      <category term="Deep learning" scheme="https://wazxser.github.io/categories/Deep-learning/"/>
    
    
      <category term="neural network" scheme="https://wazxser.github.io/tags/neural-network/"/>
    
      <category term="activation function" scheme="https://wazxser.github.io/tags/activation-function/"/>
    
  </entry>
  
  <entry>
    <title>conda和pip换源</title>
    <link href="https://wazxser.github.io/2018/08/09/conda%E5%92%8Cpip%E6%8D%A2%E6%BA%90/"/>
    <id>https://wazxser.github.io/2018/08/09/conda和pip换源/</id>
    <published>2018-08-09T09:17:12.000Z</published>
    <updated>2018-08-09T20:25:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>推荐使用国内镜像下载</p><h1 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h1><h2 id="国内源"><a href="#国内源" class="headerlink" title="国内源"></a>国内源</h2><p>清华大学：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a><br>豆瓣：<a href="http://pypi.doubanio.com/simple/" target="_blank" rel="noopener">http://pypi.doubanio.com/simple/</a><br>中科大：<a href="https://mirrors.ustc.edu.cn/pypi/web/simple/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/pypi/web/simple/</a></p><h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><p>以更换清华的源为例：</p><h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><p>使用-i参数，加上下载地址<br>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple keras</span><br></pre></td></tr></table></figure></p><h3 id="永久使用"><a href="#永久使用" class="headerlink" title="永久使用"></a>永久使用</h3><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>在~/.pip/pip.conf文件中加入如下内容，没有则创建该文件</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>找到用户目录下的AppData文件夹（显示隐藏项目或者资源管理器中直接搜索%appdata%），进入Local创建pip文件夹，创建pip.ini文件，添加如下内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">timeout = <span class="number">6000</span></span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure></p><h1 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h1><h2 id="国内源-1"><a href="#国内源-1" class="headerlink" title="国内源"></a>国内源</h2><p>conda国内的源貌似只有清华的：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></p><h2 id="更换源-1"><a href="#更换源-1" class="headerlink" title="更换源"></a>更换源</h2><h3 id="换源命令"><a href="#换源命令" class="headerlink" title="换源命令"></a>换源命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><h3 id="换回默认源"><a href="#换回默认源" class="headerlink" title="换回默认源"></a>换回默认源</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;推荐使用国内镜像下载&lt;/p&gt;
&lt;h1 id=&quot;pip&quot;&gt;&lt;a href=&quot;#pip&quot; class=&quot;headerlink&quot; title=&quot;pip&quot;&gt;&lt;/a&gt;pip&lt;/h1&gt;&lt;h2 id=&quot;国内源&quot;&gt;&lt;a href=&quot;#国内源&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="环境搭建" scheme="https://wazxser.github.io/categories/build-environment/"/>
    
    
      <category term="conda" scheme="https://wazxser.github.io/tags/conda/"/>
    
      <category term="pip" scheme="https://wazxser.github.io/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>cplex的使用环境</title>
    <link href="https://wazxser.github.io/2018/08/09/cplex%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83/"/>
    <id>https://wazxser.github.io/2018/08/09/cplex的使用环境/</id>
    <published>2018-08-09T09:01:47.000Z</published>
    <updated>2018-08-14T15:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近的一个实验中用到了cplex和keras，现有的支持只有cplex的win版本，并且只支持python2的32位版本，所以在这里记录一下环境搭建过程。</p><h1 id="CPLEX"><a href="#CPLEX" class="headerlink" title="CPLEX"></a>CPLEX</h1><p>CPLEX是IBM发布的一款软件，提供了用来求解线性规划（LP）等相关问题的函数库，并且支持Python、Matlab等多种语言的调用，详细介绍可以参考IBM的官方介绍文档。</p><p>试过pip install cplex和conda install -c IBMDecisionOptimization docplex cplex这两种，import cplex没有问题，但是跑实验时会报错求解问题size超过限制。<br>有安装可执行文件，所以双击正常安装，需要java环境，按照提示操作就可以，安装完成后的界面和eclipse相似。</p><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p>python选择通过anaconda来安装，anaconda包含了Python、Conda等一系列的工具包，使用起来很方便。<br><a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">官网</a>下载安装包，正常安装</p><h1 id="theano"><a href="#theano" class="headerlink" title="theano"></a>theano</h1><p>因为tensorflow在windows下不支持python2，所以用theano做keras的后端</p><h2 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h2><p>试过CodeBlock内置的MinGW和单独下载安装MinGW，都不行，会报编译错误，只能通过conda来安装了，安装之前一定要换源<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install mingw libpython</span><br></pre></td></tr></table></figure></p><p>下载安装完成后，要在Path中添加环境变量<br>D:(anaconda的安装目录)\MinGW\bin<br>D:(anaconda的安装目录)\MinGW\i686-w64-mingw32(依平台而定)\lib<br>并且注意，Path中只能有这一个MniGw变量。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install theano</span><br></pre></td></tr></table></figure><p>添加PYTHONPATH环境变量<br>D:(anaconda的安装目录)\Lib\site-packages\theano</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在C:\Users(用户名)目录下新建.theanorc.txt文件，添加内容入下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[blas]</span><br><span class="line">ldflags=</span><br><span class="line"></span><br><span class="line">[gcc]</span><br><span class="line">cxxflags=-ID:\(anaconda的安装目录)\MinGW\i686-w64-mingw32\include</span><br></pre></td></tr></table></figure></p><h1 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h1><p>安装之前一定要换源<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install keras</span><br></pre></td></tr></table></figure></p><p>因为keras默认后端是tensorflow，所以要修改位theano<br>修改后端文件，在C:\Users(用户名).keras\keras.json中，把tensorflow改成theano</p><h1 id="python调用cplex"><a href="#python调用cplex" class="headerlink" title="python调用cplex"></a>python调用cplex</h1><p>在D:(cplex的安装目录)\cplex\python\x86_win32目录下运行setup.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><p>生成build文件夹<br>在环境变量PYTHONPATH中添加D:(cplex的安装目录)\cplex\python\x86_win32</p><p>这样应该就可以用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近的一个实验中用到了cplex和keras，现有的支持只有cplex的win版本，并且只支持python2的32位版本，所以在这里记录一下环境搭建过程。&lt;/p&gt;
&lt;h1 id=&quot;CPLEX&quot;&gt;&lt;a href=&quot;#CPLEX&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="环境搭建" scheme="https://wazxser.github.io/categories/build-environment/"/>
    
    
      <category term="anaconda" scheme="https://wazxser.github.io/tags/anaconda/"/>
    
      <category term="theano" scheme="https://wazxser.github.io/tags/theano/"/>
    
      <category term="keras" scheme="https://wazxser.github.io/tags/keras/"/>
    
      <category term="cplex" scheme="https://wazxser.github.io/tags/cplex/"/>
    
  </entry>
  
  <entry>
    <title>python的几个内置函数</title>
    <link href="https://wazxser.github.io/2018/01/29/python0/"/>
    <id>https://wazxser.github.io/2018/01/29/python0/</id>
    <published>2018-01-29T13:55:24.000Z</published>
    <updated>2018-01-30T22:49:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python is beautiful. (本文python环境为2.7.12)</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> (参数) : (计算表达式)</span><br></pre></td></tr></table></figure><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>目前知道的，lambda表达式在c#、java8、python都支持，主要作用为定义了一个匿名函数，使代码更加简洁</p><h1 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function, iterable, ...)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>function: 函数</li><li>iterable: 一个或多个列表</li><li>python2返回列表</li><li>python3返回迭代器</li></ul><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>map函数将列表元素依次传入函数，作为函数的参数值进行计算，返回计算结果，一般也为列表</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python2.7</span></span><br><span class="line">print(map(<span class="keyword">lambda</span> x, y : x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))  <span class="comment">#打印[3, 5, 7]</span></span><br></pre></td></tr></table></figure><h1 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h1><h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable[, initializer])</span><br></pre></td></tr></table></figure><h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul><li>function: 函数，有两个参数</li><li>iterable: 可迭代对象，例如，list</li><li>initializer: 可选，初始参数</li><li>返回函数计算结果</li></ul><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>若无初始参数，reduce函数将可迭代对象的第1、2个之传入函数中进行计算，之后将计算结果与第3个值传入函数中，依次递推</p><p>若有初始参数，则第一步将初始参数和可迭代对象中第1个值传入参数中</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">print(reduce(add, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment">#打印6</span></span><br><span class="line"></span><br><span class="line">print(reduce(<span class="keyword">lambda</span> x, y: x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment">#打印6</span></span><br><span class="line"></span><br><span class="line">print(reduce(<span class="keyword">lambda</span> x, y : x+y, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">100</span>))  <span class="comment">#打印106</span></span><br></pre></td></tr></table></figure><h1 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h1><h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([iterable, ...])</span><br></pre></td></tr></table></figure><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul><li>iterable: 一个或多个迭代器</li></ul><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>zip函数，可用于将迭代器中对应元素打包成元组，返回元组列表，若迭代器元素个数不一致时，以最少的元素个数为准。<br>此外，zip函数传入*操作符，可将元组解压</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list3 = [<span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">zipped = zip(list1, list2)</span><br><span class="line">print(zipped)  <span class="comment">#打印[(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">print(zip(list1, list3)) <span class="comment">#打印[(1, 7), (2, 8)]</span></span><br><span class="line">print(zip(*zipped))  <span class="comment">#打印[(1, 2, 3), (4, 5, 6)]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python is beautiful. (本文python环境为2.7.12)&lt;/p&gt;
&lt;h1 id=&quot;lambda表达式&quot;&gt;&lt;a href=&quot;#lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;lambda表达式&quot;&gt;&lt;/a&gt;lambda表达式&lt;/
      
    
    </summary>
    
      <category term="编程语言" scheme="https://wazxser.github.io/categories/codeing-language/"/>
    
    
      <category term="python" scheme="https://wazxser.github.io/tags/python/"/>
    
  </entry>
  
</feed>
